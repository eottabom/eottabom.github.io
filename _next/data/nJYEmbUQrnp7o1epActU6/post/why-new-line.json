{"pageProps":{"postData":{"id":"why-new-line","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    hr: \"hr\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    code: \"code\",\n    img: \"img\",\n    strong: \"strong\",\n    neutral: \"neutral\",\n    success: \"success\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsx(_components.p, {\n        children: \"파일 끝에 개행이 없는 경우는 CheckStyle 을 돌리거나, github 으로 Pull Request 를 하면 경고가 뜨는 이유는\\nPOSIX 명세 때문인데, 그 현상과 POSIX 표준에 대해서 간략히 알아보자.\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"파일-끝에-개행이-없는-경우의-현상\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#파일-끝에-개행이-없는-경우의-현상\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"파일 끝에 개행이 없는 경우의 현상\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Check Style 의 결과로 \", _jsx(_components.code, {\n        children: \"File does not end with a newline.\"\n      }), \" 경고가 발생한다.\\n\", _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/check-style-result.png\",\n        alt: \"warning\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"github 에서 \", _jsx(_components.code, {\n        children: \"Pull Request\"\n      }), \" 할 때 이상한 마크도 표시되는 것을 볼 수 있다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/github-pr.png\",\n        alt: \"github-pr\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만, 프로그램을 돌리거나 코드 상에 이상이 있는 것은 전혀 아니다.\\n이는 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 명세 때문에 경고로 알려주는 것이다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"posix-표준이란\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#posix-표준이란\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"POSIX 표준이란?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"POSIX(Portable operating system interface)\"\n      }), \"는 운영체제 간의 호환성을 유지하기 위해 1980년대에 IEEE 에서 개발한 표준이다.\\n소프트웨어가 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준을 충족한다면 다른 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 호환 운영 체제와도 호환되어야 하는 것과 같다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준은 1988년에 출시된 반면에 IEEE Std 1003.1-2017 은 2017에 출시되었다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준 개발에는 여러가지 이유가 있는데 그 중에서도 응용프로그램 개발과 이식성을 쉽게 하기 위해 만들어졌기 때문에\\nUNIX 뿐만 아니라 다른 Non_UNIX 시스템에서도 사용할 수 있도록 만들었다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 표준은 어플리케이션이나 운영체제의 개발을 정의하지 않고 단지 어플리케이션과 운영체제의 계약을 설명한다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준은 C언어로 작성되었지만 모든 언어와 함께 사용할 수 있다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 는 성능 저하 없이 이식성을 달성할 수 있도록 설계 되었고, 개발자의 시간과 비용을 절약할 수 있다.\\n이식성을 달성할 수 없는 경우 모든 시스템에 대해서 코드를 작성해야하는데 이는 시간과 비용이 많이 드는 프로세스이다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"간단히 말해서 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 는 전 세계 개발자가 어플리케이션을 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준 기능과 호환 되도록 만들기 위해 따르는 \", _jsx(_components.strong, {\n        children: \"일련의 규칙 및 지침이다.\"\n      }), \"\\n이는 어플리케이션이 다른 운영 체제에서 실행될 수 있는 이유다.\\n따라서, 파일에 개행이 없는 경우, 경고를 만나게 되는 것이다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"추가적으로, \", _jsx(_components.a, {\n        href: \"https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html\",\n        children: \"IEEE Std 1003.1-2001 표준\"\n      }), \" 에 따르면,\\nText File 은 \", _jsx(_components.code, {\n        children: \"<newline>\"\n      }), \" 이 포함된 하나 이상의 줄로 구성된 문자가 포함된 파일이다.\"]\n    }), \"\\n\", _jsx(_components.neutral, {\n      children: _jsxs(_components.p, {\n        children: [\"Definitions - 3.392 Text File\\nA file that contains characters organized into one or more lines.\\nThe lines do not contain NUL characters and none can exceed LINE_MAX bytes in length, including the \", _jsx(_components.code, {\n          children: \"<newline>\"\n        }), \".\\nAlthough IEEE Std 1003.1-2001 does not distinguish between text files and binary files (see the ISO C standard),\\nmany utilities only produce predictable or meaningful output when operating on text files.\\nThe standard utilities that have such restrictions always specify \\\"text files\\\" in their STDIN or INPUT FILES sections.\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Line 은 0개 이상의 \", _jsx(_components.code, {\n        children: \"<newline>\"\n      }), \" 이 아닌 시작과 끝에 \", _jsx(_components.code, {\n        children: \"<newline>\"\n      }), \" 을 더한 시퀀스이다.\"]\n    }), \"\\n\", _jsx(_components.neutral, {\n      children: _jsxs(_components.p, {\n        children: [\"Definitions - 3.205 Line : \", _jsx(_components.code, {\n          children: \"A sequence of zero or more non- <newline>s plus a terminating <newline>.\"\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"IntelliJ 기준으로 자동으로 마지막 개행을 추가하는 옵션은 default 로 활성화 되어 있다. \", _jsx(\"br\", {}), \"\\nPreference > Editor > General > On Save > Ensure every saved file ends with a line break\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/intellij-settings.png\",\n        alt: \"intellij-settings.png\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.success, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"개인적인 생각\"\n        }), \"\\n알고 쓰는 것과 모르고 쓰는 것은 차이가 있다고 생각한다.\\nPOSIX 명세에 의해서 표준 기능과 호환 되도록 만들기 위해서 따르는 일련의 규칙과 지침을 잘 따라보자!\"]\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html\",\n          children: \"IEEE Std 1003.1-2001 표준\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.baeldung.com/linux/posix\",\n          children: \"A Guide to POSIX\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://medium.com/@cloud.devops.enthusiast/posix-59d0ee68b498\",\n          children: \"POSIX\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"파일 끝에 개행이 필요한 이유","date":"2024-06-10","tags":["Clean Code"],"summary":"File dose not end with a newline","description":"파일 끝에 개행이 필요한 이유와 POSIX 표준에 대해서 간략히 알아보자."}},"title":"파일 끝에 개행이 필요한 이유","date":"2024-06-10","tags":["Clean Code"],"summary":"File dose not end with a newline","description":"파일 끝에 개행이 필요한 이유와 POSIX 표준에 대해서 간략히 알아보자."}},"__N_SSG":true}