{"pageProps":{"postData":{"id":"why-using-grpc","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    hr: \"hr\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    strong: \"strong\",\n    code: \"code\",\n    pre: \"pre\",\n    ul: \"ul\",\n    li: \"li\",\n    note: \"note\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h4: \"h4\",\n    warning: \"warning\"\n  }, _provideComponents(), props.components), {RedText, BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  if (!RedText) _missingMdxReference(\"RedText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsx(_components.p, {\n        children: \"gRPC 는 Google 이 개발한 모든 환경에서 실행할 수 있는 오픈 소스 고성능 RPC 프레임워크이다.\\nMonolithic → MSA 로 가면서, 여러개의 서비스로 분리가 되어졌는데,\\n그렇다보니, 하나의 응답을 처리하기 위해서 빈번하게 네트워크 통신이 발생하게 되어 Latency 가 증가할 수가 있게 되었다.\\nMSA 에서 gRPC 를 도입하면 어떤 이점이 있는지? 그리고 어떤 부분을 해소할 수 있는지 알아보자.\\n더불어서 HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0 에 대해서도 알아보자.\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"monolithic--msa-전환시-network-latency\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#monolithic--msa-전환시-network-latency\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Monolithic → MSA 전환시 Network Latency\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/monolithic.png\",\n        alt: \"monolithic\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Monolithic 아키텍처에서는 하나의 Machine 에서 동일한 프로세스 내에서 실행되고, 서비스 간 통신은 \", _jsx(_components.strong, {\n        children: \"메서드 호출\"\n      }), \"로 이루어지므로 별도의 \", _jsx(_components.strong, {\n        children: \"네트워크 통신이 필요 없다.\"\n      }), \"\\n또한, 하나의 어플리케이션의 모든 서비스와 모듈이 동일한 메모리 공간에서 실행된다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/msa-network-latency.png\",\n        alt: \"msa-network-latency\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만, MSA 구조에서는 동일 장비가 아닐 수도 있는 여러 장비에 각각의 프로세스로 분리되다보니,\\n보통 \", _jsx(_components.strong, {\n        children: \"REST 통신\"\n      }), \"을 통해 메시지를 주고 받는 구조가 되는데(서버간 통신이 발생한다.), 이 때, \", _jsx(RedText, {\n        children: \"잠재적인 latency\"\n      }), \" 가 존재한다.\\n다른 Server 나 Frontend 에서 요청을 할 때 MSA 구간별 통신이 필요하다면, \", _jsx(RedText, {\n        children: \"응답속도가 저하된다는 단점\"\n      }), \" 이 존재하게 된다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"q-어떤-요인으로-인해-응답-속도-저하가-발생할까\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#q-어떤-요인으로-인해-응답-속도-저하가-발생할까\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Q. 어떤 요인으로 인해 응답 속도 저하가 발생할까?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(BlueText, {\n        children: _jsx(\"span\", {\n          style: {\n            fontSize: '1.5rem'\n          },\n          children: \"A. \"\n        })\n      }), \"HTTP 는 기본적으로 TCP 위에서 동작하기 때문에, 데이터 송수신에 앞서 \", _jsx(_components.code, {\n        children: \"3-way handshake\"\n      }), \" 과정을 거치고, \", _jsx(_components.code, {\n        children: \"4-way handshake\"\n      }), \" 과정을 통해 종료가 되는데,\\nMSA 구조와 같이 서버간 통신이 빈번하게 일어나서 데이터를 전송하고 응답을 받는 상황이라면, \", _jsx(BlueText, {\n        children: \"매번 연결을 맺고 종료 하는 과정\"\n      }), \"이 발생해서\\n\", _jsx(RedText, {\n        children: \"비효율\"\n      }), \"이 발생하게 된다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"http-10\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#http-10\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTTP 1.0\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"HTTP 1.0\"\n      }), \" 은 웹의 태동과 함께 시작된 통신 표준이다. \", _jsx(\"br\", {}), \"\\n기존의 1990년 팀 버너스리(Tim Berners-Lee) 가 최초의 웹 서버 및 클라이언트를 개발했을 때에는 상당히 단순한 구조였는데,\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"code-highlight\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"GET /index.html\\n\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"헤더 값이 없으며, Content-Type 없이 HTML 만 응답만 가능했다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"텍스트 기반 문서 전송에만 최적화 되었고, 실제 명세도 거의 없다고 해도 무방하다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"웹의 인기가 폭발적으로 증가하며, 더 정형화된 명세의 필요성이 제기 되었고, 1996년 5월 IETF 에서 HTTP/1.0 을 공식 RFC 로 등록하게 되었다.\"\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsx(\"a\", {\n        href: \"https://datatracker.ietf.org/doc/html/rfc1945\",\n        children: \"RFC-1945: Hypertext Transfer Protocol -- HTTP/1.0\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(BlueText, {\n      children: _jsx(\"span\", {\n        style: {\n          fontSize: '1.2rem'\n        },\n        children: \"HTTP 1.0 의 주요 도입 요소\"\n      })\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"기능\"\n          }), _jsx(_components.th, {\n            children: \"설명\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"요청 메서드\"\n          }), _jsx(_components.td, {\n            children: \"GET, POST, HEAD 지원\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"응답 코드\"\n          }), _jsx(_components.td, {\n            children: \"200 OK, 404 Not Found, 500 Internal Server Error 등\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"헤더 도입\"\n          }), _jsx(_components.td, {\n            children: \"Content-Type, Content-Length, Date, Server, User-Agent 등\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"버전 명시\"\n          }), _jsxs(_components.td, {\n            children: [\"요청 라인에 \", _jsx(_components.code, {\n              children: \"HTTP/1.0\"\n            }), \" 포함됨\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"MIME 타입 지원\"\n          }), _jsx(_components.td, {\n            children: \"다양한 콘텐츠 전송 기능 (HTML 외 이미지 등)\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"http-11\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#http-11\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTTP 1.1\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"HTTP 1.0\"\n      }), \"은 요청마다 계속해서 새로운 TCP 연결을 맺은 다음에 요청을 처리하고 연결을 끊는 방식이다보니, \", _jsx(_components.code, {\n        children: \"3-way handshake\"\n      }), \" 와\", _jsx(_components.code, {\n        children: \"4-way handshake\"\n      }), \"하는 과정에서\\n\", _jsx(RedText, {\n        children: \"오버헤드가 발생해서 비효율적이다.\"\n      }), \" 그리고 요청에 대한 응답을 받은 후에 다음 요청을 보낼 수 있어서 요청/응답이 순차적/직렬적으로 처리되어\\n\", _jsx(RedText, {\n        children: \"Latency\"\n      }), \" 가 발생하게 된다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"HTTP 1.1\"\n      }), \" 에서는 이러한 문제를 해결하기 위해서 \", _jsx(_components.code, {\n        children: \"Persistent Connection\"\n      }), \" 과 \", _jsx(_components.code, {\n        children: \"Pipelining\"\n      }), \" 을 지원한다.\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"1999년 6월에 표준으로 채택된, \", _jsx(_components.code, {\n          children: \"HTTP 1.1\"\n        }), \"은 웹의 핵심 전환점이 된 프로토콜이고,\\n\", _jsx(_components.code, {\n          children: \"HTTP 1.0\"\n        }), \" 의 한계를 개선하여 더 안정적이고 효율적인 웹 통신을 가능하게 하였다.\\n\", _jsx(\"a\", {\n          href: \"https://www.rfc-editor.org/rfc/rfc9110.html\",\n          children: \"HTTP 1.1 RFC-9110 문서 보러가기\"\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"1-persistent-connection-지속-연결\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#1-persistent-connection-지속-연결\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"1) Persistent Connection (지속 연결)\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/persistent-connection.png\",\n        alt: \"persistent-connection\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Client ↔ Server 간 연결을 한 번 맺으면 여러 요청을 그 연결에서 처리할 수 있게 한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"Connection: keep-alive\"\n        }), \" 헤더가 설정되어, Client 나 Server 가 명시적으로 연결을 끊지 않는 한 연결이 유지된다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"2-pipelining\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#2-pipelining\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"2) Pipelining\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/pipeliining.png\",\n        alt: \"pipeliining\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"Pipelining\"\n        }), \" 은 Client 가 Server 에 여러 요청을 \", _jsx(BlueText, {\n          children: \"연속적\"\n        }), \" 으로 보내고 순서대로 처리하는 방식이다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"Pipelining\"\n        }), \" 이 적용되면 \", _jsx(BlueText, {\n          children: \"하나의 Connection 으로 다수의 요청과 응답을 처리할 수 있게 해서 Latency 를 줄일 수 있다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.warning, {\n      children: _jsx(_components.p, {\n        children: \"하지만, 완전한 멀티플렉싱이 아닌 응답 처리를 미루는 방식이여서 각 응답의 순서는 순차적으로 처리되며,\\n결국, 앞선 응답이 지연이 생기면 자연스럽게 그 이후의 요청은 지연이 발생하게 된다.\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"http-11-의-문제점\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#http-11-의-문제점\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTTP 1.1 의 문제점\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"HTTP 1.1\"\n      }), \"은 \", _jsx(_components.code, {\n        children: \"Persistent Connection\"\n      }), \" 과 \", _jsx(_components.code, {\n        children: \"Pipelining\"\n      }), \" 같은 기능을 통해서 \", _jsx(_components.code, {\n        children: \"HTTP 1.0\"\n      }), \" 의 단점을 개선했지만, 여전히 여러 \", _jsx(_components.strong, {\n        children: \"문제점\"\n      }), \"이 남아 있다.\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"1-head-of-line-blocking-holb\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#1-head-of-line-blocking-holb\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"1) Head-of-Line Blocking (HOLB)\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/head-of-line-blocking.png\",\n        alt: \"head-of-line-blocking\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Client 가 세 개의 요청 (Request1, Request2, Request3) 을 동시에 보내지만, Server 는 순차적으로 처리한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"첫 번째 요청 (Process1) 이 처리되는 동안 다른 요청들 (Process2, Process3) 은 차단(Blocked) 되어 대기 된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"Head-of-Line Blocking 이 발생하는 이유\"\n        }), \"\\n순차적 처리 : HTTP 1.1 에서는 하나의 연결 위에서 요청이 순서대로 처리 되어야 한다.\\n직렬 응답 : 서버는 요청 받은 순서대로 응답해야하므로, 하나의 요청이 지연되면 다음 요청도 자연스럽게 지연된다.\\n리소스 다운로드 : 브라우저가 여러 리소스를 요청 할 때, 큰 파일(이미지, 동영상)이 먼저 다운로드 되면, 더 중요한 작은 파일들(css, js)이 대기한다.\"]\n      })\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"2-connection-관리의-비효율성\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#2-connection-관리의-비효율성\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"2) Connection 관리의 비효율성\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/high-server-load.png\",\n        alt: \"high-server-load\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"여러 Client 가 각각 Server 와 \", _jsx(_components.code, {\n          children: \"Persistent Connection (지속 연결)\"\n        }), \"을 유지하게 되는 경우 서버는 여러 연결을 동시에 관리해야해서 서버에 부하가 갈 수 있다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"3-header-overhead\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#3-header-overhead\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"3) Header Overhead\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: _jsx(\"img\", {\n        src: \"/img/post/grpc/why/header-overhead.png\",\n        alt: \"header-overhead\",\n        style: {\n          display: 'inline-block'\n        }\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Client 가 Server 에 여러 요청을 보낼 때, 각 요청마다 동일한 Header 를 반복해서 전송하게 된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"중복된 Header 정보는 불필요한 대역폭을 차지하게 되어 효율성이 떨어지게 된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"http-20\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#http-20\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTTP 2.0\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇듯,\"\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"1\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#1\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"1)\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"gRPC 를 도입하는 이유에 대해서 알아보자. (feat. Http 1.0 vs Http 1.1 vs Http 2.0)","date":"2024-10-15","tags":["gRPC, Study"],"summary":"Let's find out the issues with HTTP 1.0, HTTP 1.1, and the benefits of gRPC being introduced into the MSA structure.","description":"HTTP 1.0, HTTP 1.1 의 문제와 gRPC 가 MSA 구조에 도입되면 어떤 이점이 있는지 알아보자."}},"title":"gRPC 를 도입하는 이유에 대해서 알아보자. (feat. Http 1.0 vs Http 1.1 vs Http 2.0)","date":"2024-10-15","tags":["gRPC, Study"],"summary":"Let's find out the issues with HTTP 1.0, HTTP 1.1, and the benefits of gRPC being introduced into the MSA structure.","description":"HTTP 1.0, HTTP 1.1 의 문제와 gRPC 가 MSA 구조에 도입되면 어떤 이점이 있는지 알아보자."}},"__N_SSG":true}