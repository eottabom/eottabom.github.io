{"pageProps":{"postData":{"id":"ddd-core-concept","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    quote: \"quote\",\n    hr: \"hr\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    ul: \"ul\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    note: \"note\",\n    success: \"success\"\n  }, _provideComponents(), props.components), {BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsx(_components.p, {\n        children: \"도메인 주도 설계(DDD, Domain-Driven Design)는 단순한 방법론이 아닌 도메인 중심의 개발 접근법이다.\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"intro\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#intro\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Intro\"]\n    }), \"\\n\", _jsx(_components.quote, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n        }), \" 에서 배운 내용을 요약하고 정리한 부분이 포함되어 있다. \", _jsx(\"br\", {}), \"\\n책으로 읽었던 내용들을 다시 정리할 수 있었던 부분들이 많았고, 개념정리를 다시 할 수 있어서 좋았는데, 개인적으로는 연차를 막론하고 적극 추천한다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"도메인-주도-설계의-본질\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#도메인-주도-설계의-본질\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"도메인 주도 설계의 본질\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd.png\",\n        alt: \"ddd본질\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"접근법\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"DDD는 프로세스나 방법론이 아닌 \", _jsx(BlueText, {\n          children: \"패턴의 집합\"\n        }), \"이며, 상황에 맞게 \", _jsx(BlueText, {\n          children: \"선택적으로\"\n        }), \" 적용해야 한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"모델링 사이클\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"도메인 모델 = 코드 모델\"\n        }), \" 이며, 도메인이 바뀌면 코드도 바뀌고 그 반대도 성립한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"구현 가이드\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"빌딩 블록을 통해 도메인의 개념을 코드로 옮기며 \", _jsx(BlueText, {\n          children: \"복잡도를 줄인다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"불변식 기반\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Aggregate 단위의 일관성을 유지하며, 도메인 규칙의 불변성을 코드로 보장한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"엔티티-vs-값-객체\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#엔티티-vs-값-객체\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"엔티티 vs 값 객체\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"엔티티 (Entity)\"\n          }), _jsx(_components.th, {\n            children: \"값 객체 (Value Object)\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별성이 중요\"\n          }), _jsx(_components.td, {\n            children: \"속성이 중요\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"가변 (상태 변경 가능)\"\n          }), _jsx(_components.td, {\n            children: \"불변 (상태 변경 불가)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별자로 동일성 비교\"\n          }), _jsx(_components.td, {\n            children: \"속성 값으로 동등성 비교\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"생명 주기 추적 필요\"\n          }), _jsx(_components.td, {\n            children: \"대체 가능 / 엔티티의 복잡성 감소\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Entity\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"식별자\"\n        }), \" 로 구분되며, 상태 변경이 가능하다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"생명 주기 관리가 필요하며, \", _jsx(BlueText, {\n          children: \"동일성 비교가 중요하다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Value Object\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"속성\"\n        }), \" 이 중요하고, \", _jsx(BlueText, {\n          children: \"불변성\"\n        }), \"을 가진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Entity 의 복잡성을 줄이는 역할을 수행한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"값이 같으면 동일한 객체로 취급하며, \", _jsx(BlueText, {\n          children: \"동등성 비교가 핵심이다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"상태 변경 로직은 \", _jsx(\"b\", {\n          children: \" Entity \"\n        }), \" 에 집중시키고, 값을 \", _jsx(\"b\", {\n          children: \"Value Object\"\n        }), \" 로 추출해 구조를 단순화하자.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"어그리게이트-aggregate\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#어그리게이트-aggregate\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"어그리게이트 (Aggregate)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/aggregate.png\",\n        alt: \"aggregate\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"정의\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"여러 Entity 와 Value Object 를 하나로 묶는 단위\\n\", _jsx(_components.strong, {\n          children: \"경계\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 는 캡슐화 경계를 형성하며, 외부에서는 \", _jsx(BlueText, {\n          children: \"루트 엔티티만 참조\"\n        }), \" 가능\\n\", _jsx(_components.strong, {\n          children: \"트랜잭션\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 처리\\n\", _jsx(_components.strong, {\n          children: \"불변식\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내부 도메인 상태의 일관성을 보장\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"루트 Entity 는 전역 식별성을 가지고 있고, 궁극적으로 불변식을 검사할 책임이 있다. \", _jsx(\"br\", {}), \"\\n경계 안의 Entity 는 지역 식별성을 가지고 있으며, 외부에서는 무조건 루트 Entity 만 참조 가능하다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"리포지토리-repository\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#리포지토리-repository\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"리포지토리 (Repository)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"역할\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 \", _jsx(BlueText, {\n          children: \"영속성\"\n        }), \" 을 관리하며, 데이터 저장 및 검색을 담당하다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DDD 에서는 원래는 Repository 는 컬렉션과 비슷한데, 메모리상에 객체가 있는 것처럼 쓰는 객체이지만 현대에는 Database 라고 보면 된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"설계 원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"객체 단위가 아닌 \", _jsx(BlueText, {\n          children: \"Aggregate 단위\"\n        }), \"로 Repository 를 생성한다. (Aggregate 당 하나의 Repository)\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID를 통해 외부에서 참조, 내부에서는 객체로 참조한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"연관-관계-설계-원칙\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#연관-관계-설계-원칙\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"연관 관계 설계 원칙\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"도메인 중심의 \", _jsx(_components.strong, {\n          children: \"행위 기반 모델링\"\n        }), \"이 중요하며, 연관 관계는 최소화해야 유지보수성이 좋아진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"양방향 참조는 복잡성을 증가시키므로 가급적이면 단방향으로 설계한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"1대 N 관계는 지연 로딩 문제로 인해서 선호하지 않고, N대 1 관계를 선호한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID 참조를 통해 외부 참조를 최소화하고, Aggregate 내부에서는 객체 참조를 통해 탐색한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"서비스-계층-구조\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#서비스-계층-구조\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"서비스 계층 구조\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/service-hierarchy.png\",\n        alt: \"서비스계층구조\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"도메인 서비스\"\n        }), \": 도메인 로직이지만 Aggregate 에 넣기 애매한 로직 담당\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"애플리케이션 서비스\"\n        }), \": 비즈니스 흐름을 조합\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"인프라 서비스\"\n        }), \": 외부 시스템과 연결 (DB, MQ 등)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"설계-접근법\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#설계-접근법\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"설계 접근법\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계접근법\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"책임 주도 설계 → 객체지향 사고를 기반으로 설계\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"계약에 의한 설계 → \", _jsx(BlueText, {\n          children: \"불변식\"\n        }), \" 을 기준으로 로직을 구성\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-적용-사이클--애자일과의-유사점\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-적용-사이클--애자일과의-유사점\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 적용 사이클 & 애자일과의 유사점\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd-cycle.png\",\n        alt: \"DDD 적용 사이클\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DDD 의 적용 흐름 사이클은 애자일 방법론과 매우 밀접하게 연관이 있는데, 두 접근법 모두 반복적이고 점진적인 개선을 중요시 한다는 특성이 있다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"반복적 개발\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"한 번에 완벽한 시스템을 구축하기 보다는 \", _jsx(_components.strong, {\n          children: \"반복적인 사이클\"\n        }), \" 을 통해 \", _jsx(_components.strong, {\n          children: \"점진적\"\n        }), \" 으로 시스템을 발전 시키는 접근법이다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"지속적인 피드백\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일에서 중요시하는 지속적인 피드백 루프가 DDD 의 테스트 - 리팩토팅 - 도메인 분석 순환과 유사하다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"협업 중심\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일은 개발자와 이해관계자 간의 긴밀한 협업을 강조하고, DDD 는 도메인 전문가와 개발자 간의 지식 공유와 협업이 핵심이다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"변화 수용\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일과 DDD 모두 요구사항과 이해의 변화를 자연스럽게 수용하는 프레임워크를 제공한다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"점진적 모델 개선\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일의 점진적 개발 방식은 DDD 에서 도메인 모델을 점진적으로 발견하고 개선해 나가는 과정과 동일하다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.quote, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"DDD의 핵심 가치\"\n        }), _jsx(\"br\", {}), \"\\n도메인 중심 설계는 일관성을 유지하며, 시스템을 명확하게 분할할 수 있도록 돕는다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-실용적인-적용-tips\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-실용적인-적용-tips\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"💡 실용적인 적용 Tips\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"정형화 강박 금지\"\n        }), \": 상황에 따라 유연하게 모델링\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"초기 VO 모델링 → Entity로 승격\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"반복적 개선\"\n        }), \"을 전제로 설계\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.success, {\n      children: _jsxs(_components.p, {\n        children: [\"💡 \", _jsx(\"b\", {\n          children: \"정리\"\n        }), _jsx(\"br\", {}), \"\\nDDD 는 복잡한 도메인을 코드로 명확하게 표현하기 위한 사고방식이다. \", _jsx(\"br\", {}), \"\\n도메인 모델과 코드 모델의 일관성 유지, 불변식 보장, 행위 중심 모델링이 핵심이며,\\n패턴을 무조건 따르기보단 \", _jsx(\"b\", {\n          children: \"상황에 맞는 유연한 적용\"\n        }), \"이 중요하다. \", _jsx(\"br\", {}), \"\\n→ 오버엔지니어링을 경계 해야 한다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"조영호님 강의: 도메인 주도 설계의 사실과 오해\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."}},"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."}},"__N_SSG":true}