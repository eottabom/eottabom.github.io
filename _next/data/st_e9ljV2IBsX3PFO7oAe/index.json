{"pageProps":{"allPostsData":[{"id":"jpa-determine-entity-is-new","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    hr: \"hr\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    code: \"code\",\n    pre: \"pre\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components), {BlueText, RedText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  if (!RedText) _missingMdxReference(\"RedText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\":::info\\nSpring Data JPA 를 사용하다보면 save() 메서드 호출 시 내부적으로 persist() 를 호출할지, merge() 를 호출 할 지 결정하게 된다. \", _jsx(\"br\", {}), \"\\n이 결정은 해당 Entity 가 새로운 Entity 인지 여부에 따라 결정되는데, Spring Data JPA 는 Entity 가 새로운지 어떻게 판단하는지 알아보자.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"신규-entity-판단-방식\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#신규-entity-판단-방식\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"신규 Entity 판단 방식\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Spring Data JPA 는 내부적으로 \", _jsx(_components.code, {\n        children: \"JpaEntityInformation\"\n      }), \" 의 \", _jsx(_components.code, {\n        children: \"isNew(T entity)\"\n      }), \" 메서드를 호출해서 판단한다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-java\",\n        children: \"@Override\\npublic boolean isNew(T entity) {\\n    if (versionAttribute.isEmpty()\\n        || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) {\\n        return super.isNew(entity);\\n    }\\n    BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);\\n    return versionAttribute.map(it -> wrapper.getPropertyValue(it.getName()) == null).orElse(true);\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"@Version\"\n        }), \" 필드가 있다면 → 해당 버전 필드 값이 null 인지 여부로 판단\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"@Version\"\n        }), \" 필드가 없다면 → \", _jsx(_components.code, {\n          children: \"@Id\"\n        }), \" 필드가 null 이거나, primitive 타입일 경우, 0인지 여부로 판단\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n즉, ID 가 null 이면 \", _jsx(_components.strong, {\n        children: \"신규 Entity 로 간주\"\n      }), \"하여 \", _jsx(_components.strong, {\n        children: \"persist()\"\n      }), \" 가 호출된다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"직접-id-를-지정한-경우의-동작\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#직접-id-를-지정한-경우의-동작\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"직접 ID 를 지정한 경우의 동작\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"ID를 직접 지정하고 \", _jsx(_components.code, {\n        children: \"save()\"\n      }), \" 를 호출하면, JPA 는 해당 Entity 가 기존에 존재한다고 판단하여 merge()를 수행한다. \", _jsx(\"br\", {}), \"\\n이때 실제 Database 에 해당 ID가 존재하지 않으면, \", _jsx(BlueText, {\n        children: \" SELECT 쿼리는 0건을 반환하고 \"\n      }), \" \", _jsx(\"br\", {}), \"\\nJPA 는 병합용 엔티티를 새로 생성하여 INSERT 를 시도하거나, 제약 조건 위반으로 예외가 발생할 수 있다. \", _jsx(\"br\", {}), \"\\n\", _jsx(RedText, {\n        children: \" 결국, 신규 Entity 임에도 JPA 는 기존 데이터처럼 인식하게 되어, 의도치 않은 UPDATE 또는 INSERT 실패로 이어질 수 있다 \"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n\", _jsx(_components.strong, {\n        children: \"merge\"\n      }), \" 는 \", _jsx(_components.strong, {\n        children: \"UPDATE\"\n      }), \" 뿐만 아니라, \", _jsx(_components.strong, {\n        children: \"INSERT\"\n      }), \" 도 가능하지만, \", _jsx(\"br\", {}), \"\\n직접 ID 가 지정된 신규 엔티티에는 매우 위험하다.\\n:::\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이를 해결 하기 위한 방법으로는 \", _jsx(_components.code, {\n        children: \"Persistable<T>\"\n      }), \" 인터페이스를 구현하면 된다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-java\",\n        children: \"// User.class\\n\\n@Entity\\n@Table(name = \\\"users\\\")\\n@EntityListeners(UserEntityListener.class)\\npublic class User implements Persistable<String> {\\n\\n\\t@Id\\n\\tprivate String id;\\n\\n\\tprivate String name;\\n\\n\\tprivate boolean isNew = true;\\n\\n\\tprotected User() {\\n\\n\\t}\\n\\n\\tpublic User(String id, String name) {\\n\\t\\tthis.id = id;\\n\\t\\tthis.name = name;\\n\\t}\\n\\n\\t@Override\\n\\tpublic String getId() {\\n\\t\\treturn this.id;\\n\\t}\\n\\n\\tpublic void setId(String id) {\\n\\t\\tthis.id = id;\\n\\t}\\n\\n\\tpublic String getName() {\\n\\t\\treturn this.name;\\n\\t}\\n\\n\\t@Override\\n\\tpublic boolean isNew() {\\n\\t\\treturn this.isNew;\\n\\t}\\n\\n\\tpublic void setIsNew(boolean isNew) {\\n\\t\\tthis.isNew = isNew;\\n\\t}\\n\\n}\\n\\n// UserEntityListener.class\\n\\npublic class UserEntityListener {\\n\\t@PostPersist\\n\\t@PostLoad\\n\\tpublic void setNotNew(User user) {\\n\\t\\tSystem.out.println(\\\"@PostPersist/@PostLoad called\\\");\\n\\t\\tuser.setIsNew(false);\\n\\t}\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"persist-vs-merge\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#persist-vs-merge\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"persist() vs merge()\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"구분\"\n          }), _jsx(_components.th, {\n            children: \"persist()\"\n          }), _jsx(_components.th, {\n            children: \"merge()\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"동작\"\n          }), _jsx(_components.td, {\n            children: \"새로운 Entity 를 영속성 컨텍스트에 등록\"\n          }), _jsx(_components.td, {\n            children: \"준영속 객체를 병합하여 관리\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"SELECT 쿼리\"\n          }), _jsx(_components.td, {\n            children: \"❌\"\n          }), _jsx(_components.td, {\n            children: \"✅ 먼저 조회 후 merge\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"ID 필요 여부\"\n          }), _jsx(_components.td, {\n            children: \"❌\"\n          }), _jsx(_components.td, {\n            children: \"✅\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"성능\"\n          }), _jsx(_components.td, {\n            children: \"빠름 (직접 INSERT)\"\n          }), _jsx(_components.td, {\n            children: \"느릴수 있다 (SELECT + UPDATE)\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":::note\\n신규 객체를 merge() 로 처리하면 불필요한 SELECT 쿼리가 발생하고 성능 저하 가능성이 존재하게 된다.\\n:::\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"신규-entity-판단이-중요한-이유는-무엇일까\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#신규-entity-판단이-중요한-이유는-무엇일까\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"신규 Entity 판단이 중요한 이유는 무엇일까?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Spring Data JPA 의 \", _jsx(_components.code, {\n        children: \"SimpleJpaRepository\"\n      }), \" 는 \", _jsx(_components.code, {\n        children: \"save()\"\n      }), \" 에서 다음과 같이 동작한다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-java\",\n        children: \"@Transactional\\npublic <S extends T> S save(S entity) {\\n    if (entityInformation.isNew(entity)) {\\n        entityManager.persist(entity); // INSERT\\n        return entity;\\n    } else {\\n        return entityManager.merge(entity); // SELECT → UPDATE, 존재하면 UPDATE 없으면 INSERT 가능성 있음\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"ID 를 직접 설정했지만, \", _jsx(_components.code, {\n        children: \"isNew()\"\n      }), \" 는 false 가 되어, \", _jsx(_components.code, {\n        children: \"merge()\"\n      }), \" 를 호출하게 되고, \", _jsx(\"br\", {}), \"\\nDatabase 에는 해당 ID 가 존재하지 않지만, 신규 Entity 임에도 불구하고, \", _jsx(_components.code, {\n        children: \"SELECT\"\n      }), \" 후 \", _jsx(_components.code, {\n        children: \"UPDATE\"\n      }), \" 를 하게 되어 (이 때, database 조회) 실패 또는 데이터 무결성 오류가 발생할 수 있고, 비효율적이다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":::note\\n정확한 isNew() 제어는 성능, 정합성, 쿼리 효율성 측면에서 매우 중요하다.\\n:::\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"요약\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#요약\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"요약\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"상황\"\n          }), _jsx(_components.th, {\n            children: \"처리방식\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"ID 없거나 null → 신규 Entity\"\n          }), _jsx(_components.td, {\n            children: \"persist()\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"ID가 존재하지만 실제 DB 에는 없음\"\n          }), _jsx(_components.td, {\n            children: \"merge() 호출 → 실패 가능성 / 비효율\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"ID 를 직접 설정한 신규 Entity\"\n          }), _jsx(_components.td, {\n            children: \"Persistable<T> + isNew() 로 명시 필요\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::tip\\n\", _jsx(\"a\", {\n        href: \"https://github.com/eottabom/let-me-code/tree/main/src/main/java/com/eottabom/letmecode/example/_01_jpa_entity\",\n        children: \"예제 코드 보러가기 (클릭)\"\n      }), \"\\n:::\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\":::success\\n💡 \", _jsx(\"b\", {\n        children: \"정리\"\n      }), _jsx(\"br\", {}), \"\\nSpring Data JPA 는 내부적으로 isNew() 를 통해서 신규 Entity 여부를 판단한다. \", _jsx(\"br\", {}), \"\\nID 는 존재하지만 실제 DB 에 없는 경우 SELECT + UPDATE 후 merge 를 하므로 정합성이 떨어질 수 있고, 비효율적이다. \", _jsx(\"br\", {}), \"\\nID 를 직접 설정했을 경우는 Persistable + isNew() 로 명시하는 것이 필요하다. \", _jsx(\"br\", {}), \"\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/support/JpaEntityInformation.html\",\n          children: \"Spring Docs - JpaEntityInformation\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://docs.spring.io/spring-data/jpa/reference/jpa/entity-persistence.html\",\n          children: \"Spring Docs - entity-persistence\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Spring Data JPA - 새로운 Entity 판별","date":"2025-04-30","tags":["Spring","JPA"],"summary":"How does Spring Data JPA Determine if an Entity is New?","description":"Spring Data JPA 에서 Entity 가 새로운 것인지 판단하는 방법에 대해서 알아보자."}},"title":"Spring Data JPA - 새로운 Entity 판별","date":"2025-04-30","tags":["Spring","JPA"],"summary":"How does Spring Data JPA Determine if an Entity is New?","description":"Spring Data JPA 에서 Entity 가 새로운 것인지 판단하는 방법에 대해서 알아보자."},{"id":"ddd-core-concept","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    hr: \"hr\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    ul: \"ul\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components), {BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \":::info\\n도메인 주도 설계(DDD, Domain-Driven Design)는 단순한 방법론이 아닌 도메인 중심의 개발 접근법이다.\\n:::\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"intro\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#intro\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Intro\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::quote\\n\", _jsx(_components.a, {\n        href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n        children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n      }), \" 에서 배운 내용을 요약하고 정리한 부분이 포함되어 있다. \", _jsx(\"br\", {}), \"\\n책으로 읽었던 내용들을 다시 정리할 수 있었던 부분들이 많았고, 개념정리를 다시 할 수 있어서 좋았는데, 개인적으로는 연차를 막론하고 적극 추천한다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"도메인-주도-설계의-본질\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#도메인-주도-설계의-본질\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"도메인 주도 설계의 본질\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd.png\",\n        alt: \"ddd본질\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"접근법\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"DDD는 프로세스나 방법론이 아닌 \", _jsx(BlueText, {\n          children: \"패턴의 집합\"\n        }), \"이며, 상황에 맞게 \", _jsx(BlueText, {\n          children: \"선택적으로\"\n        }), \" 적용해야 한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"모델링 사이클\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"도메인 모델 = 코드 모델\"\n        }), \" 이며, 도메인이 바뀌면 코드도 바뀌고 그 반대도 성립한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"구현 가이드\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"빌딩 블록을 통해 도메인의 개념을 코드로 옮기며 \", _jsx(BlueText, {\n          children: \"복잡도를 줄인다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"불변식 기반\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Aggregate 단위의 일관성을 유지하며, 도메인 규칙의 불변성을 코드로 보장한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"엔티티-vs-값-객체\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#엔티티-vs-값-객체\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"엔티티 vs 값 객체\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"엔티티 (Entity)\"\n          }), _jsx(_components.th, {\n            children: \"값 객체 (Value Object)\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별성이 중요\"\n          }), _jsx(_components.td, {\n            children: \"속성이 중요\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"가변 (상태 변경 가능)\"\n          }), _jsx(_components.td, {\n            children: \"불변 (상태 변경 불가)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별자로 동일성 비교\"\n          }), _jsx(_components.td, {\n            children: \"속성 값으로 동등성 비교\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"생명 주기 추적 필요\"\n          }), _jsx(_components.td, {\n            children: \"대체 가능 / 엔티티의 복잡성 감소\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Entity\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"식별자\"\n        }), \" 로 구분되며, 상태 변경이 가능하다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"생명 주기 관리가 필요하며, \", _jsx(BlueText, {\n          children: \"동일성 비교가 중요하다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Value Object\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"속성\"\n        }), \" 이 중요하고, \", _jsx(BlueText, {\n          children: \"불변성\"\n        }), \"을 가진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Entity 의 복잡성을 줄이는 역할을 수행한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"값이 같으면 동일한 객체로 취급하며, \", _jsx(BlueText, {\n          children: \"동등성 비교가 핵심이다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n상태 변경 로직은 \", _jsx(\"b\", {\n        children: \" Entity \"\n      }), \" 에 집중시키고, 값을 \", _jsx(\"b\", {\n        children: \"Value Object\"\n      }), \" 로 추출해 구조를 단순화하자.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"어그리게이트-aggregate\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#어그리게이트-aggregate\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"어그리게이트 (Aggregate)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/aggregate.png\",\n        alt: \"aggregate\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"정의\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"여러 Entity 와 Value Object 를 하나로 묶는 단위\\n\", _jsx(_components.strong, {\n          children: \"경계\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 는 캡슐화 경계를 형성하며, 외부에서는 \", _jsx(BlueText, {\n          children: \"루트 엔티티만 참조\"\n        }), \" 가능\\n\", _jsx(_components.strong, {\n          children: \"트랜잭션\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 처리\\n\", _jsx(_components.strong, {\n          children: \"불변식\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내부 도메인 상태의 일관성을 보장\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n루트 Entity 는 전역 식별성을 가지고 있고, 궁극적으로 불변식을 검사할 책임이 있다. \", _jsx(\"br\", {}), \"\\n경계 안의 Entity 는 지역 식별성을 가지고 있으며, 외부에서는 무조건 루트 Entity 만 참조 가능하다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"리포지토리-repository\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#리포지토리-repository\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"리포지토리 (Repository)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"역할\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 \", _jsx(BlueText, {\n          children: \"영속성\"\n        }), \" 을 관리하며, 데이터 저장 및 검색을 담당하다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DDD 에서는 원래는 Repository 는 컬렉션과 비슷한데, 메모리상에 객체가 있는 것처럼 쓰는 객체이지만 현대에는 Database 라고 보면 된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"설계 원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"객체 단위가 아닌 \", _jsx(BlueText, {\n          children: \"Aggregate 단위\"\n        }), \"로 Repository 를 생성한다. (Aggregate 당 하나의 Repository)\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID를 통해 외부에서 참조, 내부에서는 객체로 참조한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"연관-관계-설계-원칙\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#연관-관계-설계-원칙\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"연관 관계 설계 원칙\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"도메인 중심의 \", _jsx(_components.strong, {\n          children: \"행위 기반 모델링\"\n        }), \"이 중요하며, 연관 관계는 최소화해야 유지보수성이 좋아진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"양방향 참조는 복잡성을 증가시키므로 가급적이면 단방향으로 설계한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"1대 N 관계는 지연 로딩 문제로 인해서 선호하지 않고, N대 1 관계를 선호한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID 참조를 통해 외부 참조를 최소화하고, Aggregate 내부에서는 객체 참조를 통해 탐색한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"서비스-계층-구조\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#서비스-계층-구조\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"서비스 계층 구조\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/service-hierarchy.png\",\n        alt: \"서비스계층구조\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"도메인 서비스\"\n        }), \": 도메인 로직이지만 Aggregate 에 넣기 애매한 로직 담당\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"애플리케이션 서비스\"\n        }), \": 비즈니스 흐름을 조합\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"인프라 서비스\"\n        }), \": 외부 시스템과 연결 (DB, MQ 등)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"설계-접근법\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#설계-접근법\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"설계 접근법\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계접근법\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"책임 주도 설계 → 객체지향 사고를 기반으로 설계\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"계약에 의한 설계 → \", _jsx(BlueText, {\n          children: \"불변식\"\n        }), \" 을 기준으로 로직을 구성\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-적용-사이클--애자일과의-유사점\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-적용-사이클--애자일과의-유사점\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 적용 사이클 & 애자일과의 유사점\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd-cycle.png\",\n        alt: \"DDD 적용 사이클\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DDD 의 적용 흐름 사이클은 애자일 방법론과 매우 밀접하게 연관이 있는데, 두 접근법 모두 반복적이고 점진적인 개선을 중요시 한다는 특성이 있다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"반복적 개발\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"한 번에 완벽한 시스템을 구축하기 보다는 \", _jsx(_components.strong, {\n          children: \"반복적인 사이클\"\n        }), \" 을 통해 \", _jsx(_components.strong, {\n          children: \"점진적\"\n        }), \" 으로 시스템을 발전 시키는 접근법이다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"지속적인 피드백\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일에서 중요시하는 지속적인 피드백 루프가 DDD 의 테스트 - 리팩토팅 - 도메인 분석 순환과 유사하다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"협업 중심\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일은 개발자와 이해관계자 간의 긴밀한 협업을 강조하고, DDD 는 도메인 전문가와 개발자 간의 지식 공유와 협업이 핵심이다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"변화 수용\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일과 DDD 모두 요구사항과 이해의 변화를 자연스럽게 수용하는 프레임워크를 제공한다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"점진적 모델 개선\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일의 점진적 개발 방식은 DDD 에서 도메인 모델을 점진적으로 발견하고 개선해 나가는 과정과 동일하다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::quote\\n\", _jsx(\"b\", {\n        children: \"DDD의 핵심 가치\"\n      }), _jsx(\"br\", {}), \"\\n도메인 중심 설계는 일관성을 유지하며, 시스템을 명확하게 분할할 수 있도록 돕는다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-실용적인-적용-tips\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-실용적인-적용-tips\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"💡 실용적인 적용 Tips\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"정형화 강박 금지\"\n        }), \": 상황에 따라 유연하게 모델링\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"초기 VO 모델링 → Entity로 승격\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"반복적 개선\"\n        }), \"을 전제로 설계\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n      children: [\":::success\\n💡 \", _jsx(\"b\", {\n        children: \"정리\"\n      }), _jsx(\"br\", {}), \"\\nDDD 는 복잡한 도메인을 코드로 명확하게 표현하기 위한 사고방식이다. \", _jsx(\"br\", {}), \"\\n도메인 모델과 코드 모델의 일관성 유지, 불변식 보장, 행위 중심 모델링이 핵심이며,\\n패턴을 무조건 따르기보단 \", _jsx(\"b\", {\n        children: \"상황에 맞는 유연한 적용\"\n      }), \"이 중요하다. \", _jsx(\"br\", {}), \"\\n→ 오버엔지니어링을 경계 해야 한다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"조영호님 강의: 도메인 주도 설계의 사실과 오해\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."}},"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."},{"id":"ddd-fact-misunderstanding","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    hr: \"hr\",\n    strong: \"strong\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components), {BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\":::info\\n도메인 주도 설계(DDD, Domain-Driven Desigin) 는 여전히 많은 기업과 개발자들 사이에서 각광을 받고 있다. \", _jsx(\"br\", {}), \"\\n특히, 마이크로서비스 아키텍처(MSA) 가 확산이 되면서, DDD 의 개념이 적극적으로 활용되고 있다. \", _jsx(\"br\", {}), \"\\n그렇다면, 도메인 주도 설계는 무엇이며, 도메인 주도 설계의 사실과 오해에 대해서 알아보자.\\n:::\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"intro\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#intro\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Intro\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::quote\\n도메인 주도 설계가 처음 이야기 되었을 때와 현재의 도메인 주도 설계는 조금은 다르다고 할 수 있다. \", _jsx(\"br\", {}), \"\\n하지만, 초창기의 도메인 주도 설계의 철학과 핵심 원칙에서는 크게 벗어나지는 않는다. \", _jsx(\"br\", {}), \"\\n개인적으로는 에릭 에반스가 작성한, \", _jsx(_components.a, {\n        href: \"https://www.yes24.com/Product/Goods/5312881\",\n        children: \"\\\"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\\\"\"\n      }), \" 라는 책은 개발자라면, 읽어보기를 권장하고 싶고, \", _jsx(\"br\", {}), \"\\n\", _jsx(_components.a, {\n        href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n        children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n      }), \"도 추천한다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-란-무엇인가\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-란-무엇인가\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 란 무엇인가?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n\", _jsx(\"b\", {\n        children: \"도메인 주도 설계(Domain-Driven Design, DDD)\"\n      }), \" 는 \", _jsx(\"br\", {}), \" 복잡한 비즈니스 도메인을 효과적으로 다루기 위해 \", _jsx(\"b\", {\n        children: \"도메인 중심의 사고방식과 설계 원칙을 적용하는 철학적인 관점\"\n      }), \"에 가깝다. \", _jsx(\"br\", {}), \"\\n특정한 방법론이나 아키텍처가 아니라, 순수하게 \", _jsx(\"b\", {\n        children: \"비즈니스 중심으로 사고하는 방식\"\n      }), \" 이다.\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-의-철학\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-의-철학\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 의 철학\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n\", _jsx(\"b\", {\n        children: \" 복잡한 소프트웨어를 효과적으로 관리하고, 비즈니스 문제를 올바르게 모델링하여 해결 하는 것\"\n      }), \"이 핵심 철학이다.\\n:::\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"단순히 코드를 작성하는 것이 아니라, \", _jsx(_components.strong, {\n        children: \"도메인 전문가와 개발자가 협력하여 도메인을 깊이 이해하고, 이를 소프트웨어에 반영하는 방식\"\n      }), \" 을 추구하는 것이고, \", _jsx(\"br\", {}), \"\\nDDD 는 화려한 기술이나 기법, 마법이 아니라, \", _jsx(BlueText, {\n        children: \"복잡한 소프트웨어를 효과적으로 관리하는 철학과 전략\"\n      }), \" 이라고 할 수 있다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-의-핵심-원칙\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-의-핵심-원칙\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 의 핵심 원칙\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 1) 도메인과 모델 우선 (핵심 철학) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"소프트웨어는 현실 세계의 복잡성을 해결하기 위한 것이므로, 도메인을 깊게 이해하고 모델을 만들어야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"기술적인 해결책 보다는 \", _jsx(BlueText, {\n          children: \"비즈니스 도메인 문제 해결\"\n        }), \"을 우선시 한다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"도메인 전문가와 협력하여 \", _jsx(BlueText, {\n          children: \"비즈니스 개념을 정확히 반영\"\n        }), \" 해야 한다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인을 단순화 하고, 핵심 개념을 명확히 모델링 해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 2) 유비쿼터스 언어 (Ubiquitous Language) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"도메인 전문가와 개발자가 같은 용어를 사용해야 오해를 줄이고, 효과적으로 협업할 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 전문가와 개발자가 동일한 언어를 사용하여 커뮤니케이션해야 혼선이 일어나지 않는다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"이 언어는 \", _jsx(_components.strong, {\n          children: \"코드, 문서, 대화\"\n        }), \"에서 일관되게 유지되어야 한다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모델과 코드가 유비쿼터스 언어를 반영해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 3) 바운디드 컨텍스트 (Bounded Context) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"하나의 모델이 모든 곳에 통하지 않으므로, 모델의 적용 범위를 명확히 정의하는 바운디드 컨텍스트를 설정한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"하나의 도메인을 여러개의 경계(Context) 로 나눈다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 컨텍스트 내에서 유비쿼터스 언어를 일관되게 적용한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"컨텍스트 간 관계를 명확히 정의하고, 통합 전략을 고민해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 4) 어그리게이트 (Aggregate)  \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"무질서한 객체들 대신, 모델을 더 작은 단위로 구조화하여 일관성과 응집력을 가진 어그리게이트를 만들자.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"어그리게이트는 도메인 객체의 논리적 그룹이며, 일관성을 유지하는 단위이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Root Entity 가 변경을 관리하고, 외부에서 직접 내부 객체를 조작할 수 없다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트랜잭션 범위를 고려하여 적절한 크기로 모델링 해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 5) 도메인 이벤트 (Domain Event) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"비즈니스 흐름을 명확하게 표현하기 위해 중요한 상태 변화는 이벤트로 명확하게 드러내자.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 내에서 중요한 상태 변화를 이벤트로 표현한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 기반 설계를 활용하여 시스템 간 결합도를 낮춘다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트는 과거 시제로 표현하며, 도메인 로직의 핵심 흐름을 반영해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 6) 리포지토리 (Repository) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"데이터베이스가 아니라, 도메인 개념을 중심적으로 접근하여 도메인 객체의 저장과 검색을 추상화한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"리포지토리는 어그리게이트를 저장하고 검색하는 역할을 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인 로직에서 직접 데이터베이스 기술을 다루지 않는다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트랜잭션을 고려하여 적절한 데이터 접근 전략을 수립한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 7) 어플리케이션 서비스 vs 도메인 서비스 \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"도메인 로직과 어플리케이션 로직을 명확히 분리하여 비즈니스 로직과 어플리케이션 로직을 혼합하지 않는다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 서비스 : 어그리게이트에 속하지 않는 도메인 로직을 처리한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"어플리케이션 서비스 : 트랜잭션, 외부 API 호출 등 어플리케이션 수준의 처리를 담당한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인 로직은 도메인 모델 내에서 처리하고, 어플리케이션 로직은 별도로 관리해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 8) 전략적 설계 (Strategic Design) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"DDD 는 단순한 전술적 패턴이 아니라 전략적 사고를 요구하므로 시스템 전체적인 설계를 고려해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"핵심 도메인(Core Domain) 을 식별하고, 여기에 집중해야 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"지원 서브도메인(Supporting Subdomain) 과 범용 서브도메인(Generic Subdomain)을 구분해야 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인의 전략적 우선순위를 정하고, 각 컨텍스트 간 협력 관계를 정의해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-핵심-원칙의-흐름\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-핵심-원칙의-흐름\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 핵심 원칙의 흐름\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"도메인 이해 → 유비쿼터스 언어 정립 → 바운디드 컨텍스트 설정 → 모델 구조화(어그리게이트, 이벤트, 리포지토리) → 전략적 설계 적용 \", _jsx(\"br\", {})]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"DDD 의 철학은 \", _jsx(_components.strong, {\n        children: \"소프트웨어가 도메인을 정확하게 반영해야 한다는 원칙\"\n      }), \" 을 중심으로 \", _jsx(_components.strong, {\n        children: \"전술적 패턴\"\n      }), \"과 \", _jsx(_components.strong, {\n        children: \"전략적 설계\"\n      }), \" 로 체계화하는 것이다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-에-대한-사실과-오해\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-에-대한-사실과-오해\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 에 대한 사실과 오해\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" DDD 에 대한 사실 \"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"질문\"\n          }), _jsx(_components.th, {\n            children: \"사실 ✅\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"특정한 아키텍처(ex: 헥사고날, MSA)를 강제하나요?\"\n          }), _jsx(_components.td, {\n            children: \"특정한 아키텍처를 강제하지 않지만, 다양한 아키텍처에서 적용 가능하다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 모델을 처음부터 완벽하게 설계 해야하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"DDD 는 \", _jsx(_components.strong, {\n              children: \"반복적인 개발과 피드백을 통한 도메인 모델을 개선\"\n            }), \" 하는 방식이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 모델이 하나여야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"하나의 시스템에서 \", _jsx(_components.strong, {\n              children: \"여러개의 도메인 모델이 존재 할 수 있다.(바운디드 컨텍스트)\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"기술적인 요소보다 비즈니스 로직이 우선되어야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"DDD 의 핵심은 \", _jsx(_components.strong, {\n              children: \"비즈니스 로직을 먼저 고려 하는 것\"\n            }), \"이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"복잡한 도메인을 다룰 때 효과적인가요?\"\n          }), _jsx(_components.td, {\n            children: \"비즈니스 로직이 복잡한 경우 DDD 를 적용하면 효과적이다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 전문가와의 협업은 필수 인가요?\"\n          }), _jsxs(_components.td, {\n            children: [\"개발자와 도메인 전문과는 밀접한 관계를 가져야하고, \", _jsx(\"br\", {}), \" 도메인 전문가와의 협업은 DDD 의 \", _jsx(_components.strong, {\n              children: \"핵심요소\"\n            }), \" 중 하나다.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" ❌ DDD 에 대한 오해 - MSA, 헥사고날, CQRS.. \"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"질문\"\n          }), _jsx(_components.th, {\n            children: \"오해 ❌\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"반드시 MSA 나 헥사고날 아키텍쳐를 해야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"무조건 MSA 를 해야 한다는 것은 오해이고, \", _jsx(\"br\", {}), \" MSA 가 각광을 받으면서 설명하기 쉬우니 DDD 로 예를 드는 것이다. \", _jsx(\"br\", {}), \" 도메인 레이어만 분리가 잘되어 있다면 헥사고날이든 MSA 든 필요가 없다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"처음부터 모든 모델을 이벤트 스토밍으로 정의 해야 하나요?\"\n          }), _jsx(_components.td, {\n            children: \"한 번에 모든 모델을 정의하는 것은 아니다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"CQRS 는 원래 DDD 의 일부였나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"CQRS 는 시스템 복잡성을 낮추기 위해서 나온 것이고, \", _jsx(\"br\", {}), \" DDD 는 복잡도가 높으면 나누자였는데, \", _jsx(\"br\", {}), \" 현대의 DDD 에서는 CQRS 가 포함되는데, CQRS 가 DDD 의 복잡성을 해결하기 때문이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"모든 프로젝트에서 반드시 필요한가?\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"비즈니스 로직이 복잡한 프로젝트에는 적합\"\n            }), \" \", _jsx(\"br\", {}), \" 하지만, 단순한 CURD 시스템에서는 오히려 부담이 될 수 있다.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" ❌ DDD 에 대한 오해 - OOP \"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"구분\"\n          }), _jsx(_components.th, {\n            children: \"객체지향(OOP)\"\n          }), _jsx(_components.th, {\n            children: \"도메인 주도 설계(DDD)\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"목적\"\n          }), _jsx(_components.td, {\n            children: \"작은 문제 해결, 유지보수 용이한 코드 배치\"\n          }), _jsx(_components.td, {\n            children: \"도메인 중심의 사고방식 적용\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"초점\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"데이터\"\n            }), \" 와 \", _jsx(_components.strong, {\n              children: \"알고리즘\"\n            }), \" 을 객체 단위로 배치\"]\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"비즈니스 도메인 로직\"\n            }), \"을 중심으로 코드 구성\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"본질\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"기술적인 개념\"\n            }), \"이 중심\"]\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"도메인의 본질을 코드로 표현하는 것\"\n            }), \"이 중심\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"모델링 범위\"\n          }), _jsx(_components.td, {\n            children: \"클래스, 인터페이스 등 기술적인 모델링\"\n          }), _jsx(_components.td, {\n            children: \"바운디드 컨텍스트를 기반으로 도메인 모델링\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"변경 관리\"\n          }), _jsx(_components.td, {\n            children: \"리팩토링을 통해 설계 개선\"\n          }), _jsx(_components.td, {\n            children: \"도메인 전문가와 협업하여 지속적 리팩토링\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":::note\\n객체지향은 기술적인 접근 방식이고, DDD 는 비즈니스 도메인을 중심으로 소프트웨어를 개발하는 방식이다.\\n:::\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"현대의-ddd\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#현대의-ddd\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"현대의 DDD\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 1) CQRS 와 이벤트 소싱의 도입 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"현래 DDD 의 일부는 아니었지만, 최근에는 복잡성을 해결하기 위해서 활용되고 포함해서 이야기 된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CQRS 는 읽기/쓰기 모델을 분리하여 성능을 개선할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 소싱을 통해 상태 변경 이력을 추적 가능하게 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 2) MSA 와 DDD 의 관계 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"바운디드 컨텍스트를 기반으로 MSA 를 설계 할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"그러나 DDD 를 한다고 반드시 MSA 를 도입할 필요는 없다.\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 3) 전략적 설계와 전술적 설계의 발전 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"현대의 DDD 에서는 구체적인 전술 패턴(CQRS, 이벤트 소싱)과 전략 패턴(바운디드 컨텍스트, 컨텍스트 맵 등)이 발전\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 4) 점진적 도입 강조 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"핵심 도메인부터 적용하고, 점신적으로 확장하는 방식이 현실적이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"처음부터 완벽한 설계를 하려 하기 보다 반복적인 리팩토링과 피드백을 통해 발전\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"cqrs-command-query-responsibility-segregation-란\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#cqrs-command-query-responsibility-segregation-란\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"CQRS (Command Query Responsibility Segregation) 란?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\":::note\\n\", _jsx(\"b\", {\n        children: \"CQRS는 \\\"명령(Command)와 조회(Query) 의 책임을 분리하는 아키텍처 패턴\\\"\"\n      }), \" 이다.\\n즉, 읽기(조회)와 쓰기(명령)을 별도의 모델로 나누어 설계하는 방식.\\n:::\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 1) CQRS 의 핵심 개념 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Command (명령)\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"생성, 수정, 삭제와 같이 데이터를 변경하는 작업\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"데이터 일관성과 트랜잭션을 유지하는 것이 중요\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Query (조회)\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"검색, 조회와 같이 데이터를 읽는 작업\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"성능 최적활르 위해 별도의 읽기 모델을 구성할 수 있다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 2) CQRS 를 왜 사용할까? \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"읽기/쓰기 성능 최적화가 가능하여 조회가 많은 시스템에서 빠른 성능을 제공할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"읽기와 쓰기를 각각 독립적으로 확장 가능하여 확장성이 향상된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"복잡한 도메인 로직을 분리하여 유지보수성이 개선된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":::warning\\n그러나, 구현이 복잡해지고 유지보수가 어려워 질 수 가 있으며, 데이터 동기화가 필요할 수 있다.\\n:::\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\":::success\\n💡 \", _jsx(\"b\", {\n        children: \"정리\"\n      }), _jsx(\"br\", {}), \"\\nDDD 의 핵심 철학은 비즈니스 도메인을 깊게 이해하고 소프트웨어에 정확히 반영하는 것이다. \", _jsx(\"br\", {}), \"\\nDDD 는 모든 프로젝트에 적용해야만 하는 것은 아니고, 비즈니스 복잡성에 따라 적절히 활용하는 것이다. \", _jsx(\"br\", {}), \"\\n핵심 도메인에 집중하고, 변화에 유연하게 대응할 수 있도록 설계하는 것이 철학이라고 볼 수 있다. \", _jsx(\"br\", {}), \"\\nDDD 를 적용한다면 모든 문제를 해결할 수 있다는 것은 잘못됐다. 왜냐면 DDD 는 철학과 사상에 가깝기 때문이다. \", _jsx(\"br\", {}), \"\\n도메인 전문가와 개발자가 끊임 없이 협력 유비쿼터스 언어로 소통하고 발전해나가는 것이 중요하다. \", _jsx(\"br\", {}), \"\\n:::\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"\\\"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\\\"\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"도메인 주도 설계의 사실과 오해","date":"2025-02-22","tags":["DDD"],"summary":"Domain-Driven Design Fact and Misunderstanding","description":"도메인 주도 설계(DDD, Domain-Driven Design)의 사실과 오해"}},"title":"도메인 주도 설계의 사실과 오해","date":"2025-02-22","tags":["DDD"],"summary":"Domain-Driven Design Fact and Misunderstanding","description":"도메인 주도 설계(DDD, Domain-Driven Design)의 사실과 오해"}],"gradientsForPosts":["from-yellow-400 via-green-500 to-teal-500","from-emerald-400 to-lime-500"]},"__N_SSG":true}