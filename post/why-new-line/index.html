<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Eottabom&#x27;s Lab. - 어느 따뜻한 봄날이 나에게도 오겠지... 공부하는 개발자 기술 블로그</title><meta name="next-head-count" content="3"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/3d32e0b2c5e4002d.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/3d32e0b2c5e4002d.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9812adf83da216f2.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-03cd576e71e4cd66.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-b3e5bad5ec63c840.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-488ad85de98997d1.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/609-3bdadfe3937533de.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-0055c32415dec95c.js" defer="" crossorigin=""></script><script src="/_next/static/Ita_pj5V91WIlZ-Oo7drR/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/Ita_pj5V91WIlZ-Oo7drR/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="fixed top-0 left-0 w-full h-1 z-50 bg-transparent"><div class="h-full bg-gradient-to-r from-black via-blue-500 to-teal-400 transition-all duration-150" style="width:0%"></div></div><header class="flex justify-end items-center px-6 py-4"><div class="flex gap-6 items-center"><a class="text-black hover:text-blue-300" href="/"><span class="font-bold">Main</span></a><a class="text-black hover:text-blue-300 font-bold" href="/post/">Post</a><a class="text-black hover:text-blue-300 font-bold" href="/about/">About</a></div></header><div class="max-w-[90rem] mx-auto px-6 py-20 flex gap-16"><main class="flex-1 max-w-3xl prose prose-xl mr-[17rem]"><h1 class="text-4xl font-bold mb-4">파일 끝에 개행이 필요한 이유</h1><p class="text-gray-500 text-sm mb-8">2024-06-10</p><article><div class="my-4 px-4 py-3 rounded-md prose bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-400 text-blue-900 dark:text-blue-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-blue-700 dark:text-blue-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-blue-700 dark:text-blue-300"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>파일 끝에 개행이 없는 경우는 CheckStyle 을 돌리거나, github 으로 Pull Request 를 하면 경고가 뜨는 이유는</div><div class="space-y-1 text-mi pl-[1.3rem] text-blue-700 dark:text-blue-300"><div>POSIX 명세 때문인데, 그 현상과 POSIX 표준에 대해서 간략히 알아보자.</div></div></div>
<hr/>
<h3 id="파일-끝에-개행이-없는-경우의-현상"><a aria-hidden="true" tabindex="-1" href="#파일-끝에-개행이-없는-경우의-현상"><span class="icon icon-link"></span></a>파일 끝에 개행이 없는 경우의 현상</h3>
<p>Check Style 의 결과로 <code>File does not end with a newline.</code> 경고가 발생한다.
<img src="/img/post/clean-code/new-line/check-style-result.png" alt="warning"/></p>
<p>github 에서 <code>Pull Request</code> 할 때 이상한 마크도 표시되는 것을 볼 수 있다.</p>
<p><img src="/img/post/clean-code/new-line/github-pr.png" alt="github-pr"/></p>
<p>하지만, 프로그램을 돌리거나 코드 상에 이상이 있는 것은 전혀 아니다.
이는 <code>POSIX</code> 명세 때문에 경고로 알려주는 것이다.</p>
<hr/>
<h3 id="posix-표준이란"><a aria-hidden="true" tabindex="-1" href="#posix-표준이란"><span class="icon icon-link"></span></a>POSIX 표준이란?</h3>
<p><code>POSIX(Portable operating system interface)</code>는 운영체제 간의 호환성을 유지하기 위해 1980년대에 IEEE 에서 개발한 표준이다.
소프트웨어가 <code>POSIX</code> 표준을 충족한다면 다른 <code>POSIX</code> 호환 운영 체제와도 호환되어야 하는 것과 같다.</p>
<p><code>POSIX</code> 표준은 1988년에 출시된 반면에 IEEE Std 1003.1-2017 은 2017에 출시되었다.
<code>POSIX</code> 표준 개발에는 여러가지 이유가 있는데 그 중에서도 응용프로그램 개발과 이식성을 쉽게 하기 위해 만들어졌기 때문에
UNIX 뿐만 아니라 다른 Non_UNIX 시스템에서도 사용할 수 있도록 만들었다.</p>
<p>이 표준은 어플리케이션이나 운영체제의 개발을 정의하지 않고 단지 어플리케이션과 운영체제의 계약을 설명한다.
<code>POSIX</code> 표준은 C언어로 작성되었지만 모든 언어와 함께 사용할 수 있다.
<code>POSIX</code> 는 성능 저하 없이 이식성을 달성할 수 있도록 설계 되었고, 개발자의 시간과 비용을 절약할 수 있다.
이식성을 달성할 수 없는 경우 모든 시스템에 대해서 코드를 작성해야하는데 이는 시간과 비용이 많이 드는 프로세스이다.</p>
<p>간단히 말해서 <code>POSIX</code> 는 전 세계 개발자가 어플리케이션을 <code>POSIX</code> 표준 기능과 호환 되도록 만들기 위해 따르는 <strong>일련의 규칙 및 지침이다.</strong>
이는 어플리케이션이 다른 운영 체제에서 실행될 수 있는 이유다.
따라서, 파일에 개행이 없는 경우, 경고를 만나게 되는 것이다.</p>
<p>추가적으로, <a href="https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html">IEEE Std 1003.1-2001 표준</a> 에 따르면,
Text File 은 <code>&lt;newline&gt;</code> 이 포함된 하나 이상의 줄로 구성된 문자가 포함된 파일이다.</p>
<div class="my-4 px-4 py-3 rounded-md prose bg-gray-50 dark:bg-gray-900/30 border-l-4 border-gray-400 text-gray-900 dark:text-gray-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-gray-700 dark:text-gray-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-gray-700 dark:text-gray-300"><circle cx="12" cy="12" r="10"></circle><path d="M17 12h.01"></path><path d="M12 12h.01"></path><path d="M7 12h.01"></path></svg>Definitions - 3.392 Text File</div><div class="space-y-1 text-mi pl-[1.3rem] text-gray-700 dark:text-gray-300"><div>A file that contains characters organized into one or more lines.</div><div>The lines do not contain NUL characters and none can exceed LINE_MAX bytes in length, including the <code>&lt;newline&gt;</code>.</div><div>Although IEEE Std 1003.1-2001 does not distinguish between text files and binary files (see the ISO C standard),</div><div>many utilities only produce predictable or meaningful output when operating on text files.</div><div>The standard utilities that have such restrictions always specify &quot;text files&quot; in their STDIN or INPUT FILES sections.</div></div></div>
<p>Line 은 0개 이상의 <code>&lt;newline&gt;</code> 이 아닌 시작과 끝에 <code>&lt;newline&gt;</code> 을 더한 시퀀스이다.</p>
<div class="my-4 px-4 py-3 rounded-md prose bg-gray-50 dark:bg-gray-900/30 border-l-4 border-gray-400 text-gray-900 dark:text-gray-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-gray-700 dark:text-gray-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-gray-700 dark:text-gray-300"><circle cx="12" cy="12" r="10"></circle><path d="M17 12h.01"></path><path d="M12 12h.01"></path><path d="M7 12h.01"></path></svg>Definitions - 3.205 Line : <code>A sequence of zero or more non- &lt;newline&gt;s plus a terminating &lt;newline&gt;.</code></div><div class="space-y-1 text-mi pl-[1.3rem] text-gray-700 dark:text-gray-300"></div></div>
<p>IntelliJ 기준으로 자동으로 마지막 개행을 추가하는 옵션은 default 로 활성화 되어 있다. <br/>
Preference &gt; Editor &gt; General &gt; On Save &gt; Ensure every saved file ends with a line break</p>
<p><img src="/img/post/clean-code/new-line/intellij-settings.png" alt="intellij-settings.png"/></p>
<hr/>
<div class="my-4 px-4 py-3 rounded-md prose bg-green-50 dark:bg-green-900/30 border-l-4 border-green-400 text-green-900 dark:text-green-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-green-700 dark:text-green-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-green-700 dark:text-green-300"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg><b>개인적인 생각</b></div><div class="space-y-1 text-mi pl-[1.3rem] text-green-700 dark:text-green-300"><div>알고 쓰는 것과 모르고 쓰는 것은 차이가 있다고 생각한다.</div><div>POSIX 명세에 의해서 표준 기능과 호환 되도록 만들기 위해서 따르는 일련의 규칙과 지침을 잘 따라보자!</div></div></div>
<br/>
<hr/>
<h3 id="-reference"><a aria-hidden="true" tabindex="-1" href="#-reference"><span class="icon icon-link"></span></a>📚 Reference</h3>
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html">IEEE Std 1003.1-2001 표준</a></li>
<li><a href="https://www.baeldung.com/linux/posix">A Guide to POSIX</a></li>
<li><a href="https://medium.com/@cloud.devops.enthusiast/posix-59d0ee68b498">POSIX</a></li>
</ul>
<br/>
<br/></article></main><aside class="hidden lg:block fixed right-10 top-[96px] w-60 h-[calc(100vh-96px)] pl-4 z-40 pb-[120px]"><div class="relative h-full"><div class="overflow-y-auto h-full pr-2 scrollbar-hide"><h2 class="text-sm font-semibold mb-2">🧾 목차</h2><ul class="space-y-1 text-xs sm:text-sm text-gray-700 pb-12"></ul></div></div></aside></div><a class="fixed bottom-6 right-6 z-50 bg-white border border-gray-300 rounded-lg shadow-md p-3 hover:shadow-lg transition" aria-label="목록으로 가기" href="/post/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-800"><line x1="8" x2="21" y1="6" y2="6"></line><line x1="8" x2="21" y1="12" y2="12"></line><line x1="8" x2="21" y1="18" y2="18"></line><line x1="3" x2="3.01" y1="6" y2="6"></line><line x1="3" x2="3.01" y1="12" y2="12"></line><line x1="3" x2="3.01" y1="18" y2="18"></line></svg></a></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"why-new-line","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    hr: \"hr\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    code: \"code\",\n    img: \"img\",\n    strong: \"strong\",\n    neutral: \"neutral\",\n    success: \"success\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsx(_components.p, {\n        children: \"파일 끝에 개행이 없는 경우는 CheckStyle 을 돌리거나, github 으로 Pull Request 를 하면 경고가 뜨는 이유는\\nPOSIX 명세 때문인데, 그 현상과 POSIX 표준에 대해서 간략히 알아보자.\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"파일-끝에-개행이-없는-경우의-현상\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#파일-끝에-개행이-없는-경우의-현상\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"파일 끝에 개행이 없는 경우의 현상\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Check Style 의 결과로 \", _jsx(_components.code, {\n        children: \"File does not end with a newline.\"\n      }), \" 경고가 발생한다.\\n\", _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/check-style-result.png\",\n        alt: \"warning\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"github 에서 \", _jsx(_components.code, {\n        children: \"Pull Request\"\n      }), \" 할 때 이상한 마크도 표시되는 것을 볼 수 있다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/github-pr.png\",\n        alt: \"github-pr\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만, 프로그램을 돌리거나 코드 상에 이상이 있는 것은 전혀 아니다.\\n이는 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 명세 때문에 경고로 알려주는 것이다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"posix-표준이란\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#posix-표준이란\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"POSIX 표준이란?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"POSIX(Portable operating system interface)\"\n      }), \"는 운영체제 간의 호환성을 유지하기 위해 1980년대에 IEEE 에서 개발한 표준이다.\\n소프트웨어가 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준을 충족한다면 다른 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 호환 운영 체제와도 호환되어야 하는 것과 같다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준은 1988년에 출시된 반면에 IEEE Std 1003.1-2017 은 2017에 출시되었다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준 개발에는 여러가지 이유가 있는데 그 중에서도 응용프로그램 개발과 이식성을 쉽게 하기 위해 만들어졌기 때문에\\nUNIX 뿐만 아니라 다른 Non_UNIX 시스템에서도 사용할 수 있도록 만들었다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 표준은 어플리케이션이나 운영체제의 개발을 정의하지 않고 단지 어플리케이션과 운영체제의 계약을 설명한다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준은 C언어로 작성되었지만 모든 언어와 함께 사용할 수 있다.\\n\", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 는 성능 저하 없이 이식성을 달성할 수 있도록 설계 되었고, 개발자의 시간과 비용을 절약할 수 있다.\\n이식성을 달성할 수 없는 경우 모든 시스템에 대해서 코드를 작성해야하는데 이는 시간과 비용이 많이 드는 프로세스이다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"간단히 말해서 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 는 전 세계 개발자가 어플리케이션을 \", _jsx(_components.code, {\n        children: \"POSIX\"\n      }), \" 표준 기능과 호환 되도록 만들기 위해 따르는 \", _jsx(_components.strong, {\n        children: \"일련의 규칙 및 지침이다.\"\n      }), \"\\n이는 어플리케이션이 다른 운영 체제에서 실행될 수 있는 이유다.\\n따라서, 파일에 개행이 없는 경우, 경고를 만나게 되는 것이다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"추가적으로, \", _jsx(_components.a, {\n        href: \"https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html\",\n        children: \"IEEE Std 1003.1-2001 표준\"\n      }), \" 에 따르면,\\nText File 은 \", _jsx(_components.code, {\n        children: \"\u003cnewline\u003e\"\n      }), \" 이 포함된 하나 이상의 줄로 구성된 문자가 포함된 파일이다.\"]\n    }), \"\\n\", _jsx(_components.neutral, {\n      children: _jsxs(_components.p, {\n        children: [\"Definitions - 3.392 Text File\\nA file that contains characters organized into one or more lines.\\nThe lines do not contain NUL characters and none can exceed LINE_MAX bytes in length, including the \", _jsx(_components.code, {\n          children: \"\u003cnewline\u003e\"\n        }), \".\\nAlthough IEEE Std 1003.1-2001 does not distinguish between text files and binary files (see the ISO C standard),\\nmany utilities only produce predictable or meaningful output when operating on text files.\\nThe standard utilities that have such restrictions always specify \\\"text files\\\" in their STDIN or INPUT FILES sections.\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Line 은 0개 이상의 \", _jsx(_components.code, {\n        children: \"\u003cnewline\u003e\"\n      }), \" 이 아닌 시작과 끝에 \", _jsx(_components.code, {\n        children: \"\u003cnewline\u003e\"\n      }), \" 을 더한 시퀀스이다.\"]\n    }), \"\\n\", _jsx(_components.neutral, {\n      children: _jsxs(_components.p, {\n        children: [\"Definitions - 3.205 Line : \", _jsx(_components.code, {\n          children: \"A sequence of zero or more non- \u003cnewline\u003es plus a terminating \u003cnewline\u003e.\"\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"IntelliJ 기준으로 자동으로 마지막 개행을 추가하는 옵션은 default 로 활성화 되어 있다. \", _jsx(\"br\", {}), \"\\nPreference \u003e Editor \u003e General \u003e On Save \u003e Ensure every saved file ends with a line break\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/clean-code/new-line/intellij-settings.png\",\n        alt: \"intellij-settings.png\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.success, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"개인적인 생각\"\n        }), \"\\n알고 쓰는 것과 모르고 쓰는 것은 차이가 있다고 생각한다.\\nPOSIX 명세에 의해서 표준 기능과 호환 되도록 만들기 위해서 따르는 일련의 규칙과 지침을 잘 따라보자!\"]\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://pubs.opengroup.org/onlinepubs/007904875/basedefs/xbd_chap03.html\",\n          children: \"IEEE Std 1003.1-2001 표준\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.baeldung.com/linux/posix\",\n          children: \"A Guide to POSIX\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://medium.com/@cloud.devops.enthusiast/posix-59d0ee68b498\",\n          children: \"POSIX\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"파일 끝에 개행이 필요한 이유","date":"2024-06-10","tags":["Clean Code"],"summary":"File dose not end with a newline","description":"파일 끝에 개행이 필요한 이유와 POSIX 표준에 대해서 간략히 알아보자."}},"title":"파일 끝에 개행이 필요한 이유","date":"2024-06-10","tags":["Clean Code"],"summary":"File dose not end with a newline","description":"파일 끝에 개행이 필요한 이유와 POSIX 표준에 대해서 간략히 알아보자."}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"why-new-line"},"buildId":"Ita_pj5V91WIlZ-Oo7drR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>