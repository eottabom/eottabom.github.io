<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Eottabom&#x27;s Lab. - 어느 따뜻한 봄날이 나에게도 오겠지... 공부하는 개발자 기술 블로그</title><meta name="next-head-count" content="3"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/c20c465ec9a867b9.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/c20c465ec9a867b9.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9812adf83da216f2.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-03cd576e71e4cd66.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-b3e5bad5ec63c840.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-488ad85de98997d1.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/609-3bdadfe3937533de.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-63bacc88a5cc72f9.js" defer="" crossorigin=""></script><script src="/_next/static/OaPRD9dFmEywx5IUCxacO/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/OaPRD9dFmEywx5IUCxacO/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="fixed top-0 left-0 w-full h-1 z-50 bg-transparent"><div class="h-full bg-gradient-to-r from-black via-blue-500 to-teal-400 transition-all duration-150" style="width:0%"></div></div><header class="flex justify-end items-center px-6 py-4"><div class="flex gap-6 items-center"><a class="text-black hover:text-blue-300" href="/"><span class="font-bold">Main</span></a><a class="text-black hover:text-blue-300 font-bold" href="/post/">Post</a><a class="text-black hover:text-blue-300 font-bold" href="/about/">About</a></div></header><div class="max-w-[90rem] mx-auto px-6 py-20 flex gap-16"><main class="flex-1 max-w-3xl prose prose-xl mr-[17rem]"><h1 class="text-4xl font-bold mb-4">도메인 주도 설계의 사실과 오해</h1><p class="text-gray-500 text-sm mb-8">2025-02-22</p><article><div class="my-4 px-4 py-3 rounded-md prose bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-400 text-blue-900 dark:text-blue-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-blue-700 dark:text-blue-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-blue-700 dark:text-blue-300"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>도메인 주도 설계(DDD, Domain-Driven Desigin) 는 여전히 많은 기업과 개발자들 사이에서 각광을 받고 있다. </div><div class="space-y-1 text-mi pl-[1.3rem] text-blue-700 dark:text-blue-300"><div>특히, 마이크로서비스 아키텍처(MSA) 가 확산이 되면서, DDD 의 개념이 적극적으로 활용되고 있다. </div><div>그렇다면, 도메인 주도 설계는 무엇이며, 도메인 주도 설계의 사실과 오해에 대해서 알아보자.</div></div></div>
<h3 id="intro"><a aria-hidden="true" tabindex="-1" href="#intro"><span class="icon icon-link"></span></a>Intro</h3>
<div class="my-4 px-4 py-3 rounded-md prose bg-indigo-50 dark:bg-indigo-900/30 border-l-4 border-indigo-400 text-indigo-900 dark:text-indigo-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-indigo-700 dark:text-indigo-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-indigo-700 dark:text-indigo-300"><line x1="21" x2="3" y1="6" y2="6"></line><line x1="15" x2="3" y1="12" y2="12"></line><line x1="17" x2="3" y1="18" y2="18"></line></svg>도메인 주도 설계가 처음 이야기 되었을 때와 현재의 도메인 주도 설계는 조금은 다르다고 할 수 있다. </div><div class="space-y-1 text-mi pl-[1.3rem] text-indigo-700 dark:text-indigo-300"><div>하지만, 초창기의 도메인 주도 설계의 철학과 핵심 원칙에서는 크게 벗어나지는 않는다. </div><div>개인적으로 에릭 에반스가 작성한, <a href="https://www.yes24.com/Product/Goods/5312881">&quot;도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜&quot;</a> 책은 개발자라면, 읽어보기를 권장하고 싶고, </div><div><a href="https://edu.nextstep.camp/c/SXgXIKdd/">Nextstep 에서 진행하는 조영호님의 강의인 &quot;도메인 주도 설계의 사실과 오해&quot;</a>도 추천한다.</div></div></div>
<hr/>
<h3 id="ddd-란-무엇인가"><a aria-hidden="true" tabindex="-1" href="#ddd-란-무엇인가"><span class="icon icon-link"></span></a>DDD 란 무엇인가?</h3>
<div class="my-4 px-4 py-3 rounded-md prose bg-purple-50 dark:bg-purple-900/30 border-l-4 border-purple-400 text-purple-900 dark:text-purple-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-purple-700 dark:text-purple-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-purple-700 dark:text-purple-300"><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"></path><path d="m9 12 2 2 4-4"></path></svg>도메인 주도 설계(Domain-Driven Design, DDD)는</div><div class="space-y-1 text-mi pl-[1.3rem] text-purple-700 dark:text-purple-300"><div>복잡한 비즈니스 도메인을 효과적으로 다루기 위해 <b>도메인 중심의 사고방식과 설계 원칙을 적용하는 철학적인 관점</b>에 가깝다. </div><div>특정한 방법론이나 아키텍처가 아니라, 순수하게 <b>비즈니스 중심으로 사고하는 방식</b> 이다.</div></div></div>
<hr/>
<h3 id="ddd-의-철학"><a aria-hidden="true" tabindex="-1" href="#ddd-의-철학"><span class="icon icon-link"></span></a>DDD 의 철학</h3>
<div class="my-4 px-4 py-3 rounded-md prose bg-purple-50 dark:bg-purple-900/30 border-l-4 border-purple-400 text-purple-900 dark:text-purple-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-purple-700 dark:text-purple-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-purple-700 dark:text-purple-300"><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"></path><path d="m9 12 2 2 4-4"></path></svg>복잡한 소프트웨어를 효과적으로 관리하고, 비즈니스 문제를 올바르게 모델링하여 해결 하는 것이 핵심 철학이다.</div><div class="space-y-1 text-mi pl-[1.3rem] text-purple-700 dark:text-purple-300"></div></div>
<p>단순히 코드를 작성하는 것이 아니라, <strong>도메인 전문가와 개발자가 협력하여 도메인을 깊이 이해하고, 이를 소프트웨어에 반영하는 방식</strong> 을 추구하는 것이고, <br/>
DDD 는 화려한 기술이나 기법, 마법이 아니라, <span class="text-blue-600 font-bold">복잡한 소프트웨어를 효과적으로 관리하는 철학과 전략</span> 이라고 할 수 있다.</p>
<hr/>
<h3 id="ddd-의-핵심-원칙"><a aria-hidden="true" tabindex="-1" href="#ddd-의-핵심-원칙"><span class="icon icon-link"></span></a>DDD 의 핵심 원칙</h3>
<br/>
<b> 1) 도메인과 모델 우선 (핵심 철학) </b>
<blockquote>
<p>소프트웨어는 현실 세계의 복잡성을 해결하기 위한 것이므로, 도메인을 깊게 이해하고 모델을 만들어야 한다.</p>
</blockquote>
<ul>
<li>기술적인 해결책 보다는 <span class="text-blue-600 font-bold">비즈니스 도메인 문제 해결</span>을 우선시 한다.</li>
<li>도메인 전문가와 협력하여 <span class="text-blue-600 font-bold">비즈니스 개념을 정확히 반영</span> 해야 한다.</li>
<li>도메인을 단순화 하고, 핵심 개념을 명확히 모델링 해야 한다.</li>
</ul>
<br/>
<b> 2) 유비쿼터스 언어 (Ubiquitous Language) </b>
<blockquote>
<p>도메인 전문가와 개발자가 같은 용어를 사용해야 오해를 줄이고, 효과적으로 협업할 수 있다.</p>
</blockquote>
<ul>
<li>도메인 전문가와 개발자가 동일한 언어를 사용하여 커뮤니케이션해야 혼선이 일어나지 않는다.</li>
<li>이 언어는 <strong>코드, 문서, 대화</strong>에서 일관되게 유지되어야 한다.</li>
<li>모델과 코드가 유비쿼터스 언어를 반영해야 한다.</li>
</ul>
<br/>
<b> 3) 바운디드 컨텍스트 (Bounded Context) </b>
<blockquote>
<p>하나의 모델이 모든 곳에 통하지 않으므로, 모델의 적용 범위를 명확히 정의하는 바운디드 컨텍스트를 설정한다.</p>
</blockquote>
<ul>
<li>하나의 도메인을 여러개의 경계(Context) 로 나눈다.</li>
<li>각 컨텍스트 내에서 유비쿼터스 언어를 일관되게 적용한다.</li>
<li>컨텍스트 간 관계를 명확히 정의하고, 통합 전략을 고민해야 한다.</li>
</ul>
<br/>
<b> 4) 어그리게이트 (Aggregate)  </b>
<blockquote>
<p>무질서한 객체들 대신, 모델을 더 작은 단위로 구조화하여 일관성과 응집력을 가진 어그리게이트를 만들자.</p>
</blockquote>
<ul>
<li>어그리게이트는 도메인 객체의 논리적 그룹이며, 일관성을 유지하는 단위이다.</li>
<li>Root Entity 가 변경을 관리하고, 외부에서 직접 내부 객체를 조작할 수 없다.</li>
<li>트랜잭션 범위를 고려하여 적절한 크기로 모델링 해야 한다.</li>
</ul>
<br/>
<b> 5) 도메인 이벤트 (Domain Event) </b>
<blockquote>
<p>비즈니스 흐름을 명확하게 표현하기 위해 중요한 상태 변화는 이벤트로 명확하게 드러내자.</p>
</blockquote>
<ul>
<li>도메인 내에서 중요한 상태 변화를 이벤트로 표현한다.</li>
<li>이벤트 기반 설계를 활용하여 시스템 간 결합도를 낮춘다.</li>
<li>이벤트는 과거 시제로 표현하며, 도메인 로직의 핵심 흐름을 반영해야 한다.</li>
</ul>
<br/>
<b> 6) 리포지토리 (Repository) </b>
<blockquote>
<p>데이터베이스가 아니라, 도메인 개념을 중심적으로 접근하여 도메인 객체의 저장과 검색을 추상화한다.</p>
</blockquote>
<ul>
<li>리포지토리는 어그리게이트를 저장하고 검색하는 역할을 한다.</li>
<li>도메인 로직에서 직접 데이터베이스 기술을 다루지 않는다.</li>
<li>트랜잭션을 고려하여 적절한 데이터 접근 전략을 수립한다.</li>
</ul>
<br/>
<b> 7) 어플리케이션 서비스 vs 도메인 서비스 </b>
<blockquote>
<p>도메인 로직과 어플리케이션 로직을 명확히 분리하여 비즈니스 로직과 어플리케이션 로직을 혼합하지 않는다.</p>
</blockquote>
<ul>
<li>도메인 서비스 : 어그리게이트에 속하지 않는 도메인 로직을 처리한다.</li>
<li>어플리케이션 서비스 : 트랜잭션, 외부 API 호출 등 어플리케이션 수준의 처리를 담당한다.</li>
<li>도메인 로직은 도메인 모델 내에서 처리하고, 어플리케이션 로직은 별도로 관리해야 한다.</li>
</ul>
<br/>
<b> 8) 전략적 설계 (Strategic Design) </b>
<blockquote>
<p>DDD 는 단순한 전술적 패턴이 아니라 전략적 사고를 요구하므로 시스템 전체적인 설계를 고려해야 한다.</p>
</blockquote>
<ul>
<li>핵심 도메인(Core Domain) 을 식별하고, 여기에 집중해야 한다.</li>
<li>지원 서브도메인(Supporting Subdomain) 과 범용 서브도메인(Generic Subdomain)을 구분해야 한다.</li>
<li>도메인의 전략적 우선순위를 정하고, 각 컨텍스트 간 협력 관계를 정의해야 한다.</li>
</ul>
<hr/>
<h3 id="ddd-핵심-원칙의-흐름"><a aria-hidden="true" tabindex="-1" href="#ddd-핵심-원칙의-흐름"><span class="icon icon-link"></span></a>DDD 핵심 원칙의 흐름</h3>
<br/>
<p>도메인 이해 → 유비쿼터스 언어 정립 → 바운디드 컨텍스트 설정 → 모델 구조화(어그리게이트, 이벤트, 리포지토리) → 전략적 설계 적용 <br/></p>
<p>DDD 의 철학은 <strong>소프트웨어가 도메인을 정확하게 반영해야 한다는 원칙</strong> 을 중심으로 <strong>전술적 패턴</strong>과 <strong>전략적 설계</strong> 로 체계화하는 것이다.</p>
<hr/>
<h3 id="ddd-에-대한-사실과-오해"><a aria-hidden="true" tabindex="-1" href="#ddd-에-대한-사실과-오해"><span class="icon icon-link"></span></a>DDD 에 대한 사실과 오해</h3>
<b> DDD 에 대한 사실 </b>
<table><thead><tr><th>질문</th><th>사실 ✅</th></tr></thead><tbody><tr><td>특정한 아키텍처(ex: 헥사고날, MSA)를 강제하나요?</td><td>특정한 아키텍처를 강제하지 않지만, 다양한 아키텍처에서 적용 가능하다.</td></tr><tr><td>도메인 모델을 처음부터 완벽하게 설계 해야하나요?</td><td>DDD 는 <strong>반복적인 개발과 피드백을 통한 도메인 모델을 개선</strong> 하는 방식이다.</td></tr><tr><td>도메인 모델이 하나여야 하나요?</td><td>하나의 시스템에서 <strong>여러개의 도메인 모델이 존재 할 수 있다.(바운디드 컨텍스트)</strong></td></tr><tr><td>기술적인 요소보다 비즈니스 로직이 우선되어야 하나요?</td><td>DDD 의 핵심은 <strong>비즈니스 로직을 먼저 고려 하는 것</strong>이다.</td></tr><tr><td>복잡한 도메인을 다룰 때 효과적인가요?</td><td>비즈니스 로직이 복잡한 경우 DDD 를 적용하면 효과적이다.</td></tr><tr><td>도메인 전문가와의 협업은 필수 인가요?</td><td>개발자와 도메인 전문과는 밀접한 관계를 가져야하고, <br/> 도메인 전문가와의 협업은 DDD 의 <strong>핵심요소</strong> 중 하나다.</td></tr></tbody></table>
<br/>
<b> ❌ DDD 에 대한 오해 - MSA, 헥사고날, CQRS.. </b>
<br/>
<table><thead><tr><th>질문</th><th>오해 ❌</th></tr></thead><tbody><tr><td>반드시 MSA 나 헥사고날 아키텍쳐를 해야 하나요?</td><td>무조건 MSA 를 해야 한다는 것은 오해이고, <br/> MSA 가 각광을 받으면서 설명하기 쉬우니 DDD 로 예를 드는 것이다. <br/> 도메인 레이어만 분리가 잘되어 있다면 헥사고날이든 MSA 든 필요가 없다.</td></tr><tr><td>처음부터 모든 모델을 이벤트 스토밍으로 정의 해야 하나요?</td><td>한 번에 모든 모델을 정의하는 것은 아니다.</td></tr><tr><td>CQRS 는 원래 DDD 의 일부였나요?</td><td>CQRS 는 시스템 복잡성을 낮추기 위해서 나온 것이고, <br/> DDD 는 복잡도가 높으면 나누자였는데, <br/> 현대의 DDD 에서는 CQRS 가 포함되는데, CQRS 가 DDD 의 복잡성을 해결하기 때문이다.</td></tr><tr><td>모든 프로젝트에서 반드시 필요한가?</td><td><strong>비즈니스 로직이 복잡한 프로젝트에는 적합</strong> <br/> 하지만, 단순한 CURD 시스템에서는 오히려 부담이 될 수 있다.</td></tr></tbody></table>
<br/>
<b> ❌ DDD 에 대한 오해 - OOP </b>
<br/>
<table><thead><tr><th>구분</th><th>객체지향(OOP)</th><th>도메인 주도 설계(DDD)</th></tr></thead><tbody><tr><td>목적</td><td>작은 문제 해결, 유지보수 용이한 코드 배치</td><td>도메인 중심의 사고방식 적용</td></tr><tr><td>초점</td><td><strong>데이터</strong> 와 <strong>알고리즘</strong> 을 객체 단위로 배치</td><td><strong>비즈니스 도메인 로직</strong>을 중심으로 코드 구성</td></tr><tr><td>본질</td><td><strong>기술적인 개념</strong>이 중심</td><td><strong>도메인의 본질을 코드로 표현하는 것</strong>이 중심</td></tr><tr><td>모델링 범위</td><td>클래스, 인터페이스 등 기술적인 모델링</td><td>바운디드 컨텍스트를 기반으로 도메인 모델링</td></tr><tr><td>변경 관리</td><td>리팩토링을 통해 설계 개선</td><td>도메인 전문가와 협업하여 지속적 리팩토링</td></tr></tbody></table>
<div class="my-4 px-4 py-3 rounded-md prose bg-purple-50 dark:bg-purple-900/30 border-l-4 border-purple-400 text-purple-900 dark:text-purple-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-purple-700 dark:text-purple-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-purple-700 dark:text-purple-300"><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"></path><path d="m9 12 2 2 4-4"></path></svg>객체지향은 기술적인 접근 방식이고, DDD 는 비즈니스 도메인을 중심으로 소프트웨어를 개발하는 방식이다.</div><div class="space-y-1 text-mi pl-[1.3rem] text-purple-700 dark:text-purple-300"></div></div>
<hr/>
<h3 id="현대의-ddd"><a aria-hidden="true" tabindex="-1" href="#현대의-ddd"><span class="icon icon-link"></span></a>현대의 DDD</h3>
<b> 1) CQRS 와 이벤트 소싱의 도입 </b>
<ul>
<li>현래 DDD 의 일부는 아니었지만, 최근에는 복잡성을 해결하기 위해서 활용되고 포함해서 이야기 된다.</li>
<li>CQRS 는 읽기/쓰기 모델을 분리하여 성능을 개선할 수 있다.</li>
<li>이벤트 소싱을 통해 상태 변경 이력을 추적 가능하게 한다.</li>
</ul>
<b> 2) MSA 와 DDD 의 관계 </b>
<ul>
<li>바운디드 컨텍스트를 기반으로 MSA 를 설계 할 수 있다.</li>
<li><strong>그러나 DDD 를 한다고 반드시 MSA 를 도입할 필요는 없다.</strong></li>
</ul>
<b> 3) 전략적 설계와 전술적 설계의 발전 </b>
<ul>
<li>현대의 DDD 에서는 구체적인 전술 패턴(CQRS, 이벤트 소싱)과 전략 패턴(바운디드 컨텍스트, 컨텍스트 맵 등)이 발전</li>
</ul>
<b> 4) 점진적 도입 강조 </b>
<ul>
<li>핵심 도메인부터 적용하고, 점신적으로 확장하는 방식이 현실적이다.</li>
<li>처음부터 완벽한 설계를 하려 하기 보다 반복적인 리팩토링과 피드백을 통해 발전</li>
</ul>
<hr/>
<h3 id="cqrs-command-query-responsibility-segregation-란"><a aria-hidden="true" tabindex="-1" href="#cqrs-command-query-responsibility-segregation-란"><span class="icon icon-link"></span></a>CQRS (Command Query Responsibility Segregation) 란?</h3>
<div class="my-4 px-4 py-3 rounded-md prose bg-purple-50 dark:bg-purple-900/30 border-l-4 border-purple-400 text-purple-900 dark:text-purple-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-purple-700 dark:text-purple-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-purple-700 dark:text-purple-300"><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"></path><path d="m9 12 2 2 4-4"></path></svg><b>CQRS는 &quot;명령(Command)와 조회(Query) 의 책임을 분리하는 아키텍처 패턴&quot;</b> 이다.</div><div class="space-y-1 text-mi pl-[1.3rem] text-purple-700 dark:text-purple-300"><div>즉, 읽기(조회)와 쓰기(명령)을 별도의 모델로 나누어 설계하는 방식.</div></div></div>
<b> 1) CQRS 의 핵심 개념 </b>
<ul>
<li>Command (명령)<!-- -->
<ul>
<li>생성, 수정, 삭제와 같이 데이터를 변경하는 작업</li>
<li>데이터 일관성과 트랜잭션을 유지하는 것이 중요</li>
</ul>
</li>
<li>Query (조회)<!-- -->
<ul>
<li>검색, 조회와 같이 데이터를 읽는 작업</li>
<li>성능 최적활르 위해 별도의 읽기 모델을 구성할 수 있다.</li>
</ul>
</li>
</ul>
<b> 2) CQRS 를 왜 사용할까? </b>
<ul>
<li>읽기/쓰기 성능 최적화가 가능하여 조회가 많은 시스템에서 빠른 성능을 제공할 수 있다.</li>
<li>읽기와 쓰기를 각각 독립적으로 확장 가능하여 확장성이 향상된다.</li>
<li>복잡한 도메인 로직을 분리하여 유지보수성이 개선된다.</li>
</ul>
<div class="my-4 px-4 py-3 rounded-md prose bg-yellow-50 dark:bg-yellow-900/30 border-l-4 border-yellow-400 text-yellow-900 dark:text-yellow-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-yellow-700 dark:text-yellow-200"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-yellow-700 dark:text-yellow-200"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>그러나, 구현이 복잡해지고 유지보수가 어려워 질 수 가 있으며, 데이터 동기화가 필요할 수 있다.</div><div class="space-y-1 text-mi pl-[1.3rem] text-yellow-700 dark:text-yellow-200"></div></div>
<br/>
<hr/>
<div class="my-4 px-4 py-3 rounded-md prose bg-green-50 dark:bg-green-900/30 border-l-4 border-green-400 text-green-900 dark:text-green-100"><div class="text-mi flex items-center gap-2 mt-2 mb-1 text-green-700 dark:text-green-300"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 text-green-700 dark:text-green-300"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg><b>정리</b></div><div class="space-y-1 text-mi pl-[1.3rem] text-green-700 dark:text-green-300"><div>DDD 의 핵심 철학은 비즈니스 도메인을 깊게 이해하고 소프트웨어에 정확히 반영하는 것이다.</div><div>DDD 는 모든 프로젝트에 적용해야만 하는 것은 아니고, 비즈니스 복잡성에 따라 적절히 활용하는 것이다.</div><div>핵심 도메인에 집중하고, 변화에 유연하게 대응할 수 있도록 설계하는 것이 철학이라고 볼 수 있다.</div><div>DDD 를 적용한다면 모든 문제를 해결할 수 있다는 것은 잘못됐다. 왜냐면 DDD 는 철학과 사상에 가깝기 때문이다.</div><div>도메인 전문가와 개발자가 끊임 없이 협력 유비쿼터스 언어로 소통하고 발전해나가는 것이 중요하다.</div></div></div>
<hr/>
<h3 id="-reference"><a aria-hidden="true" tabindex="-1" href="#-reference"><span class="icon icon-link"></span></a>📚 Reference</h3>
<ul>
<li><a href="https://www.yes24.com/Product/Goods/5312881">&quot;도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜&quot;</a></li>
<li><a href="https://edu.nextstep.camp/c/SXgXIKdd/">Nextstep 에서 진행하는 조영호님의 강의인 &quot;도메인 주도 설계의 사실과 오해&quot;</a></li>
</ul>
<br/>
<br/></article></main><aside class="hidden lg:block fixed right-10 top-[96px] w-60 h-[calc(100vh-96px)] pl-4 z-40 pb-[120px]"><div class="relative h-full"><div class="overflow-y-auto h-full pr-2 scrollbar-hide"><h2 class="text-sm font-semibold mb-2">🧾 목차</h2><ul class="space-y-1 text-xs sm:text-sm text-gray-700 pb-12"></ul></div></div></aside></div><a class="fixed bottom-6 right-6 z-50 bg-white border border-gray-300 rounded-lg shadow-md p-3 hover:shadow-lg transition" aria-label="목록으로 가기" href="/post/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-800"><line x1="8" x2="21" y1="6" y2="6"></line><line x1="8" x2="21" y1="12" y2="12"></line><line x1="8" x2="21" y1="18" y2="18"></line><line x1="3" x2="3.01" y1="6" y2="6"></line><line x1="3" x2="3.01" y1="12" y2="12"></line><line x1="3" x2="3.01" y1="18" y2="18"></line></svg></a></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"ddd-fact-misunderstanding","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    quote: \"quote\",\n    hr: \"hr\",\n    note: \"note\",\n    strong: \"strong\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    warning: \"warning\",\n    success: \"success\"\n  }, _provideComponents(), props.components), {BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsxs(_components.p, {\n        children: [\"도메인 주도 설계(DDD, Domain-Driven Desigin) 는 여전히 많은 기업과 개발자들 사이에서 각광을 받고 있다. \", _jsx(\"br\", {}), \"\\n특히, 마이크로서비스 아키텍처(MSA) 가 확산이 되면서, DDD 의 개념이 적극적으로 활용되고 있다. \", _jsx(\"br\", {}), \"\\n그렇다면, 도메인 주도 설계는 무엇이며, 도메인 주도 설계의 사실과 오해에 대해서 알아보자.\"]\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"intro\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#intro\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Intro\"]\n    }), \"\\n\", _jsx(_components.quote, {\n      children: _jsxs(_components.p, {\n        children: [\"도메인 주도 설계가 처음 이야기 되었을 때와 현재의 도메인 주도 설계는 조금은 다르다고 할 수 있다. \", _jsx(\"br\", {}), \"\\n하지만, 초창기의 도메인 주도 설계의 철학과 핵심 원칙에서는 크게 벗어나지는 않는다. \", _jsx(\"br\", {}), \"\\n개인적으로 에릭 에반스가 작성한, \", _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"\\\"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\\\"\"\n        }), \" 책은 개발자라면, 읽어보기를 권장하고 싶고, \", _jsx(\"br\", {}), \"\\n\", _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n        }), \"도 추천한다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-란-무엇인가\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-란-무엇인가\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 란 무엇인가?\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"도메인 주도 설계(Domain-Driven Design, DDD)는\\n복잡한 비즈니스 도메인을 효과적으로 다루기 위해 \", _jsx(\"b\", {\n          children: \"도메인 중심의 사고방식과 설계 원칙을 적용하는 철학적인 관점\"\n        }), \"에 가깝다. \", _jsx(\"br\", {}), \"\\n특정한 방법론이나 아키텍처가 아니라, 순수하게 \", _jsx(\"b\", {\n          children: \"비즈니스 중심으로 사고하는 방식\"\n        }), \" 이다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-의-철학\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-의-철학\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 의 철학\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsx(_components.p, {\n        children: \"복잡한 소프트웨어를 효과적으로 관리하고, 비즈니스 문제를 올바르게 모델링하여 해결 하는 것이 핵심 철학이다.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"단순히 코드를 작성하는 것이 아니라, \", _jsx(_components.strong, {\n        children: \"도메인 전문가와 개발자가 협력하여 도메인을 깊이 이해하고, 이를 소프트웨어에 반영하는 방식\"\n      }), \" 을 추구하는 것이고, \", _jsx(\"br\", {}), \"\\nDDD 는 화려한 기술이나 기법, 마법이 아니라, \", _jsx(BlueText, {\n        children: \"복잡한 소프트웨어를 효과적으로 관리하는 철학과 전략\"\n      }), \" 이라고 할 수 있다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-의-핵심-원칙\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-의-핵심-원칙\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 의 핵심 원칙\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 1) 도메인과 모델 우선 (핵심 철학) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"소프트웨어는 현실 세계의 복잡성을 해결하기 위한 것이므로, 도메인을 깊게 이해하고 모델을 만들어야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"기술적인 해결책 보다는 \", _jsx(BlueText, {\n          children: \"비즈니스 도메인 문제 해결\"\n        }), \"을 우선시 한다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"도메인 전문가와 협력하여 \", _jsx(BlueText, {\n          children: \"비즈니스 개념을 정확히 반영\"\n        }), \" 해야 한다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인을 단순화 하고, 핵심 개념을 명확히 모델링 해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 2) 유비쿼터스 언어 (Ubiquitous Language) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"도메인 전문가와 개발자가 같은 용어를 사용해야 오해를 줄이고, 효과적으로 협업할 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 전문가와 개발자가 동일한 언어를 사용하여 커뮤니케이션해야 혼선이 일어나지 않는다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"이 언어는 \", _jsx(_components.strong, {\n          children: \"코드, 문서, 대화\"\n        }), \"에서 일관되게 유지되어야 한다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모델과 코드가 유비쿼터스 언어를 반영해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 3) 바운디드 컨텍스트 (Bounded Context) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"하나의 모델이 모든 곳에 통하지 않으므로, 모델의 적용 범위를 명확히 정의하는 바운디드 컨텍스트를 설정한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"하나의 도메인을 여러개의 경계(Context) 로 나눈다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 컨텍스트 내에서 유비쿼터스 언어를 일관되게 적용한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"컨텍스트 간 관계를 명확히 정의하고, 통합 전략을 고민해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 4) 어그리게이트 (Aggregate)  \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"무질서한 객체들 대신, 모델을 더 작은 단위로 구조화하여 일관성과 응집력을 가진 어그리게이트를 만들자.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"어그리게이트는 도메인 객체의 논리적 그룹이며, 일관성을 유지하는 단위이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Root Entity 가 변경을 관리하고, 외부에서 직접 내부 객체를 조작할 수 없다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트랜잭션 범위를 고려하여 적절한 크기로 모델링 해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 5) 도메인 이벤트 (Domain Event) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"비즈니스 흐름을 명확하게 표현하기 위해 중요한 상태 변화는 이벤트로 명확하게 드러내자.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 내에서 중요한 상태 변화를 이벤트로 표현한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 기반 설계를 활용하여 시스템 간 결합도를 낮춘다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트는 과거 시제로 표현하며, 도메인 로직의 핵심 흐름을 반영해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 6) 리포지토리 (Repository) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"데이터베이스가 아니라, 도메인 개념을 중심적으로 접근하여 도메인 객체의 저장과 검색을 추상화한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"리포지토리는 어그리게이트를 저장하고 검색하는 역할을 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인 로직에서 직접 데이터베이스 기술을 다루지 않는다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트랜잭션을 고려하여 적절한 데이터 접근 전략을 수립한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 7) 어플리케이션 서비스 vs 도메인 서비스 \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"도메인 로직과 어플리케이션 로직을 명확히 분리하여 비즈니스 로직과 어플리케이션 로직을 혼합하지 않는다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"도메인 서비스 : 어그리게이트에 속하지 않는 도메인 로직을 처리한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"어플리케이션 서비스 : 트랜잭션, 외부 API 호출 등 어플리케이션 수준의 처리를 담당한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인 로직은 도메인 모델 내에서 처리하고, 어플리케이션 로직은 별도로 관리해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" 8) 전략적 설계 (Strategic Design) \"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"DDD 는 단순한 전술적 패턴이 아니라 전략적 사고를 요구하므로 시스템 전체적인 설계를 고려해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"핵심 도메인(Core Domain) 을 식별하고, 여기에 집중해야 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"지원 서브도메인(Supporting Subdomain) 과 범용 서브도메인(Generic Subdomain)을 구분해야 한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"도메인의 전략적 우선순위를 정하고, 각 컨텍스트 간 협력 관계를 정의해야 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-핵심-원칙의-흐름\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-핵심-원칙의-흐름\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 핵심 원칙의 흐름\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"도메인 이해 → 유비쿼터스 언어 정립 → 바운디드 컨텍스트 설정 → 모델 구조화(어그리게이트, 이벤트, 리포지토리) → 전략적 설계 적용 \", _jsx(\"br\", {})]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"DDD 의 철학은 \", _jsx(_components.strong, {\n        children: \"소프트웨어가 도메인을 정확하게 반영해야 한다는 원칙\"\n      }), \" 을 중심으로 \", _jsx(_components.strong, {\n        children: \"전술적 패턴\"\n      }), \"과 \", _jsx(_components.strong, {\n        children: \"전략적 설계\"\n      }), \" 로 체계화하는 것이다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-에-대한-사실과-오해\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-에-대한-사실과-오해\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 에 대한 사실과 오해\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" DDD 에 대한 사실 \"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"질문\"\n          }), _jsx(_components.th, {\n            children: \"사실 ✅\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"특정한 아키텍처(ex: 헥사고날, MSA)를 강제하나요?\"\n          }), _jsx(_components.td, {\n            children: \"특정한 아키텍처를 강제하지 않지만, 다양한 아키텍처에서 적용 가능하다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 모델을 처음부터 완벽하게 설계 해야하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"DDD 는 \", _jsx(_components.strong, {\n              children: \"반복적인 개발과 피드백을 통한 도메인 모델을 개선\"\n            }), \" 하는 방식이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 모델이 하나여야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"하나의 시스템에서 \", _jsx(_components.strong, {\n              children: \"여러개의 도메인 모델이 존재 할 수 있다.(바운디드 컨텍스트)\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"기술적인 요소보다 비즈니스 로직이 우선되어야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"DDD 의 핵심은 \", _jsx(_components.strong, {\n              children: \"비즈니스 로직을 먼저 고려 하는 것\"\n            }), \"이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"복잡한 도메인을 다룰 때 효과적인가요?\"\n          }), _jsx(_components.td, {\n            children: \"비즈니스 로직이 복잡한 경우 DDD 를 적용하면 효과적이다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"도메인 전문가와의 협업은 필수 인가요?\"\n          }), _jsxs(_components.td, {\n            children: [\"개발자와 도메인 전문과는 밀접한 관계를 가져야하고, \", _jsx(\"br\", {}), \" 도메인 전문가와의 협업은 DDD 의 \", _jsx(_components.strong, {\n              children: \"핵심요소\"\n            }), \" 중 하나다.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" ❌ DDD 에 대한 오해 - MSA, 헥사고날, CQRS.. \"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"질문\"\n          }), _jsx(_components.th, {\n            children: \"오해 ❌\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"반드시 MSA 나 헥사고날 아키텍쳐를 해야 하나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"무조건 MSA 를 해야 한다는 것은 오해이고, \", _jsx(\"br\", {}), \" MSA 가 각광을 받으면서 설명하기 쉬우니 DDD 로 예를 드는 것이다. \", _jsx(\"br\", {}), \" 도메인 레이어만 분리가 잘되어 있다면 헥사고날이든 MSA 든 필요가 없다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"처음부터 모든 모델을 이벤트 스토밍으로 정의 해야 하나요?\"\n          }), _jsx(_components.td, {\n            children: \"한 번에 모든 모델을 정의하는 것은 아니다.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"CQRS 는 원래 DDD 의 일부였나요?\"\n          }), _jsxs(_components.td, {\n            children: [\"CQRS 는 시스템 복잡성을 낮추기 위해서 나온 것이고, \", _jsx(\"br\", {}), \" DDD 는 복잡도가 높으면 나누자였는데, \", _jsx(\"br\", {}), \" 현대의 DDD 에서는 CQRS 가 포함되는데, CQRS 가 DDD 의 복잡성을 해결하기 때문이다.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"모든 프로젝트에서 반드시 필요한가?\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"비즈니스 로직이 복잡한 프로젝트에는 적합\"\n            }), \" \", _jsx(\"br\", {}), \" 하지만, 단순한 CURD 시스템에서는 오히려 부담이 될 수 있다.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"b\", {\n      children: \" ❌ DDD 에 대한 오해 - OOP \"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"구분\"\n          }), _jsx(_components.th, {\n            children: \"객체지향(OOP)\"\n          }), _jsx(_components.th, {\n            children: \"도메인 주도 설계(DDD)\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"목적\"\n          }), _jsx(_components.td, {\n            children: \"작은 문제 해결, 유지보수 용이한 코드 배치\"\n          }), _jsx(_components.td, {\n            children: \"도메인 중심의 사고방식 적용\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"초점\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"데이터\"\n            }), \" 와 \", _jsx(_components.strong, {\n              children: \"알고리즘\"\n            }), \" 을 객체 단위로 배치\"]\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"비즈니스 도메인 로직\"\n            }), \"을 중심으로 코드 구성\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"본질\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"기술적인 개념\"\n            }), \"이 중심\"]\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"도메인의 본질을 코드로 표현하는 것\"\n            }), \"이 중심\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"모델링 범위\"\n          }), _jsx(_components.td, {\n            children: \"클래스, 인터페이스 등 기술적인 모델링\"\n          }), _jsx(_components.td, {\n            children: \"바운디드 컨텍스트를 기반으로 도메인 모델링\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"변경 관리\"\n          }), _jsx(_components.td, {\n            children: \"리팩토링을 통해 설계 개선\"\n          }), _jsx(_components.td, {\n            children: \"도메인 전문가와 협업하여 지속적 리팩토링\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsx(_components.p, {\n        children: \"객체지향은 기술적인 접근 방식이고, DDD 는 비즈니스 도메인을 중심으로 소프트웨어를 개발하는 방식이다.\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"현대의-ddd\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#현대의-ddd\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"현대의 DDD\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 1) CQRS 와 이벤트 소싱의 도입 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"현래 DDD 의 일부는 아니었지만, 최근에는 복잡성을 해결하기 위해서 활용되고 포함해서 이야기 된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CQRS 는 읽기/쓰기 모델을 분리하여 성능을 개선할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 소싱을 통해 상태 변경 이력을 추적 가능하게 한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 2) MSA 와 DDD 의 관계 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"바운디드 컨텍스트를 기반으로 MSA 를 설계 할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"그러나 DDD 를 한다고 반드시 MSA 를 도입할 필요는 없다.\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 3) 전략적 설계와 전술적 설계의 발전 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"현대의 DDD 에서는 구체적인 전술 패턴(CQRS, 이벤트 소싱)과 전략 패턴(바운디드 컨텍스트, 컨텍스트 맵 등)이 발전\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 4) 점진적 도입 강조 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"핵심 도메인부터 적용하고, 점신적으로 확장하는 방식이 현실적이다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"처음부터 완벽한 설계를 하려 하기 보다 반복적인 리팩토링과 피드백을 통해 발전\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"cqrs-command-query-responsibility-segregation-란\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#cqrs-command-query-responsibility-segregation-란\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"CQRS (Command Query Responsibility Segregation) 란?\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"CQRS는 \\\"명령(Command)와 조회(Query) 의 책임을 분리하는 아키텍처 패턴\\\"\"\n        }), \" 이다.\\n즉, 읽기(조회)와 쓰기(명령)을 별도의 모델로 나누어 설계하는 방식.\"]\n      })\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 1) CQRS 의 핵심 개념 \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Command (명령)\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"생성, 수정, 삭제와 같이 데이터를 변경하는 작업\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"데이터 일관성과 트랜잭션을 유지하는 것이 중요\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Query (조회)\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"검색, 조회와 같이 데이터를 읽는 작업\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"성능 최적활르 위해 별도의 읽기 모델을 구성할 수 있다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"b\", {\n      children: \" 2) CQRS 를 왜 사용할까? \"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"읽기/쓰기 성능 최적화가 가능하여 조회가 많은 시스템에서 빠른 성능을 제공할 수 있다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"읽기와 쓰기를 각각 독립적으로 확장 가능하여 확장성이 향상된다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"복잡한 도메인 로직을 분리하여 유지보수성이 개선된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.warning, {\n      children: _jsx(_components.p, {\n        children: \"그러나, 구현이 복잡해지고 유지보수가 어려워 질 수 가 있으며, 데이터 동기화가 필요할 수 있다.\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.success, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"정리\"\n        }), \"\\nDDD 의 핵심 철학은 비즈니스 도메인을 깊게 이해하고 소프트웨어에 정확히 반영하는 것이다.\\nDDD 는 모든 프로젝트에 적용해야만 하는 것은 아니고, 비즈니스 복잡성에 따라 적절히 활용하는 것이다.\\n핵심 도메인에 집중하고, 변화에 유연하게 대응할 수 있도록 설계하는 것이 철학이라고 볼 수 있다.\\nDDD 를 적용한다면 모든 문제를 해결할 수 있다는 것은 잘못됐다. 왜냐면 DDD 는 철학과 사상에 가깝기 때문이다.\\n도메인 전문가와 개발자가 끊임 없이 협력 유비쿼터스 언어로 소통하고 발전해나가는 것이 중요하다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"\\\"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\\\"\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"도메인 주도 설계의 사실과 오해","date":"2025-02-22","tags":["DDD"],"summary":"Domain-Driven Design Fact and Misunderstanding","description":"도메인 주도 설계(DDD, Domain-Driven Design)의 사실과 오해"}},"title":"도메인 주도 설계의 사실과 오해","date":"2025-02-22","tags":["DDD"],"summary":"Domain-Driven Design Fact and Misunderstanding","description":"도메인 주도 설계(DDD, Domain-Driven Design)의 사실과 오해"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"ddd-fact-misunderstanding"},"buildId":"OaPRD9dFmEywx5IUCxacO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>