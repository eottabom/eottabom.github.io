<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Eottabom&#x27;s Lab. - 어느 따뜻한 봄날이 나에게도 오겠지... 공부하는 개발자 기술 블로그</title><meta name="next-head-count" content="3"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/9a2acf777ebb067d.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/9a2acf777ebb067d.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9812adf83da216f2.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-03cd576e71e4cd66.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-b3e5bad5ec63c840.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-488ad85de98997d1.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/609-3bdadfe3937533de.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-6bedc106a0817b43.js" defer="" crossorigin=""></script><script src="/_next/static/lO0LaOnoEt2PK4Zp9myxs/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/lO0LaOnoEt2PK4Zp9myxs/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><header class="flex justify-end items-center px-6 py-4"><div class="flex gap-6 items-center"><a class="text-black hover:text-blue-300" href="/"><span class="font-bold">Main</span></a><a class="text-black hover:text-blue-300 font-bold" href="/post/">Post</a><a class="text-black hover:text-blue-300 font-bold" href="/about/">About</a></div></header><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-12 py-20 flex"><main class="flex-1 prose prose-xl max-w-4xl"><h1 class="text-4xl font-bold mb-4">도메인 주도 설계의 핵심 개념</h1><p class="text-gray-500 text-sm mb-8">2025-03-01</p><article><div class="px-4 py-2 my-4 rounded bg-blue-50 border-l-4 border-blue-400 text-blue-900"><div class="prose-sm"><p>도메인 주도 설계(DDD, Domain-Driven Design)는 단순한 방법론이 아닌 도메인 중심의 개발 접근법이다.</p></div></div>
<h3 id="intro"><a aria-hidden="true" tabindex="-1" href="#intro"><span class="icon icon-link"></span></a>Intro</h3>
<div class="px-4 py-2 my-4 rounded bg-indigo-50 border-l-4 border-indigo-400 text-indigo-900"><div class="prose-sm"><p><a href="https://edu.nextstep.camp/c/SXgXIKdd/">Nextstep 에서 진행하는 조영호님의 강의인 &quot;도메인 주도 설계의 사실과 오해&quot;</a> 에서 배운 내용을 요약하고 정리한 부분이 포함되어 있다. <br/>
책으로 읽었던 내용들을 다시 정리할 수 있었던 부분들이 많았고, 개념정리를 다시 할 수 있어서 좋았는데, 개인적으로는 연차를 막론하고 적극 추천한다.</p></div></div>
<hr/>
<h3 id="도메인-주도-설계의-본질"><a aria-hidden="true" tabindex="-1" href="#도메인-주도-설계의-본질"><span class="icon icon-link"></span></a>도메인 주도 설계의 본질</h3>
<p><img src="/img/post/ddd/ddd.png" alt="ddd본질"/></p>
<ol>
<li><strong>접근법</strong></li>
</ol>
<ul>
<li>DDD는 프로세스나 방법론이 아닌 <span class="text-blue-600 font-bold">패턴의 집합</span>이며, 상황에 맞게 <span class="text-blue-600 font-bold">선택적으로</span> 적용해야 한다.</li>
</ul>
<ol start="2">
<li><strong>모델링 사이클</strong></li>
</ol>
<ul>
<li><span class="text-blue-600 font-bold">도메인 모델 = 코드 모델</span> 이며, 도메인이 바뀌면 코드도 바뀌고 그 반대도 성립한다.</li>
</ul>
<ol start="3">
<li><strong>구현 가이드</strong></li>
</ol>
<ul>
<li>빌딩 블록을 통해 도메인의 개념을 코드로 옮기며 <span class="text-blue-600 font-bold">복잡도를 줄인다.</span></li>
</ul>
<ol start="4">
<li><strong>불변식 기반</strong></li>
</ol>
<ul>
<li>Aggregate 단위의 일관성을 유지하며, 도메인 규칙의 불변성을 코드로 보장한다.</li>
</ul>
<hr/>
<h3 id="엔티티-vs-값-객체"><a aria-hidden="true" tabindex="-1" href="#엔티티-vs-값-객체"><span class="icon icon-link"></span></a>엔티티 vs 값 객체</h3>
<table><thead><tr><th>엔티티 (Entity)</th><th>값 객체 (Value Object)</th></tr></thead><tbody><tr><td>식별성이 중요</td><td>속성이 중요</td></tr><tr><td>가변 (상태 변경 가능)</td><td>불변 (상태 변경 불가)</td></tr><tr><td>식별자로 동일성 비교</td><td>속성 값으로 동등성 비교</td></tr><tr><td>생명 주기 추적 필요</td><td>대체 가능 / 엔티티의 복잡성 감소</td></tr></tbody></table>
<p><strong>Entity</strong></p>
<ul>
<li><span class="text-blue-600 font-bold">식별자</span> 로 구분되며, 상태 변경이 가능하다.</li>
<li>생명 주기 관리가 필요하며, <span class="text-blue-600 font-bold">동일성 비교가 중요하다.</span></li>
</ul>
<p><strong>Value Object</strong></p>
<ul>
<li><span class="text-blue-600 font-bold">속성</span> 이 중요하고, <span class="text-blue-600 font-bold">불변성</span>을 가진다.</li>
<li>Entity 의 복잡성을 줄이는 역할을 수행한다.</li>
<li>값이 같으면 동일한 객체로 취급하며, <span class="text-blue-600 font-bold">동등성 비교가 핵심이다.</span></li>
</ul>
<div class="px-4 py-2 my-4 rounded bg-purple-50 border-l-4 border-purple-400 text-purple-900"><div class="prose-sm"><p>상태 변경 로직은 <b> Entity </b> 에 집중시키고, 값을 <b>Value Object</b> 로 추출해 구조를 단순화하자.</p></div></div>
<hr/>
<h3 id="어그리게이트-aggregate"><a aria-hidden="true" tabindex="-1" href="#어그리게이트-aggregate"><span class="icon icon-link"></span></a>어그리게이트 (Aggregate)</h3>
<p><img src="/img/post/ddd/aggregate.png" alt="aggregate"/></p>
<p><strong>정의</strong></p>
<ul>
<li>여러 Entity 와 Value Object 를 하나로 묶는 단위
<strong>경계</strong></li>
<li>Aggregate 는 캡슐화 경계를 형성하며, 외부에서는 <span class="text-blue-600 font-bold">루트 엔티티만 참조</span> 가능
<strong>트랜잭션</strong></li>
<li>Aggregate 단위로 처리
<strong>불변식</strong></li>
<li>내부 도메인 상태의 일관성을 보장</li>
</ul>
<div class="px-4 py-2 my-4 rounded bg-purple-50 border-l-4 border-purple-400 text-purple-900"><div class="prose-sm"><p>루트 Entity 는 전역 식별성을 가지고 있고, 궁극적으로 불변식을 검사할 책임이 있다. <br/>
경계 안의 Entity 는 지역 식별성을 가지고 있으며, 외부에서는 무조건 루트 Entity 만 참조 가능하다.</p></div></div>
<hr/>
<h3 id="리포지토리-repository"><a aria-hidden="true" tabindex="-1" href="#리포지토리-repository"><span class="icon icon-link"></span></a>리포지토리 (Repository)</h3>
<p><strong>역할</strong></p>
<ul>
<li>Aggregate 단위로 <span class="text-blue-600 font-bold">영속성</span> 을 관리하며, 데이터 저장 및 검색을 담당하다.</li>
<li>DDD 에서는 원래는 Repository 는 컬렉션과 비슷한데, 메모리상에 객체가 있는 것처럼 쓰는 객체이지만 현대에는 Database 라고 보면 된다.</li>
</ul>
<p><strong>설계 원칙</strong></p>
<ul>
<li>객체 단위가 아닌 <span class="text-blue-600 font-bold">Aggregate 단위</span>로 Repository 를 생성한다. (Aggregate 당 하나의 Repository)</li>
<li>ID를 통해 외부에서 참조, 내부에서는 객체로 참조한다.</li>
</ul>
<hr/>
<h3 id="연관-관계-설계-원칙"><a aria-hidden="true" tabindex="-1" href="#연관-관계-설계-원칙"><span class="icon icon-link"></span></a>연관 관계 설계 원칙</h3>
<p><img src="/img/post/ddd/design-principles.png" alt="설계원칙"/></p>
<ul>
<li>도메인 중심의 <strong>행위 기반 모델링</strong>이 중요하며, 연관 관계는 최소화해야 유지보수성이 좋아진다.</li>
<li>양방향 참조는 복잡성을 증가시키므로 가급적이면 단방향으로 설계한다.</li>
<li>1대 N 관계는 지연 로딩 문제로 인해서 선호하지 않고, N대 1 관계를 선호한다.</li>
<li>ID 참조를 통해 외부 참조를 최소화하고, Aggregate 내부에서는 객체 참조를 통해 탐색한다.</li>
</ul>
<hr/>
<h3 id="서비스-계층-구조"><a aria-hidden="true" tabindex="-1" href="#서비스-계층-구조"><span class="icon icon-link"></span></a>서비스 계층 구조</h3>
<p><img src="/img/post/ddd/service-hierarchy.png" alt="서비스계층구조"/></p>
<ul>
<li><strong>도메인 서비스</strong>: 도메인 로직이지만 Aggregate 에 넣기 애매한 로직 담당</li>
<li><strong>애플리케이션 서비스</strong>: 비즈니스 흐름을 조합</li>
<li><strong>인프라 서비스</strong>: 외부 시스템과 연결 (DB, MQ 등)</li>
</ul>
<hr/>
<h3 id="설계-접근법"><a aria-hidden="true" tabindex="-1" href="#설계-접근법"><span class="icon icon-link"></span></a>설계 접근법</h3>
<p><img src="/img/post/ddd/design-principles.png" alt="설계접근법"/></p>
<ul>
<li>책임 주도 설계 → 객체지향 사고를 기반으로 설계</li>
<li>계약에 의한 설계 → <span class="text-blue-600 font-bold">불변식</span> 을 기준으로 로직을 구성</li>
</ul>
<hr/>
<h3 id="ddd-적용-사이클--애자일과의-유사점"><a aria-hidden="true" tabindex="-1" href="#ddd-적용-사이클--애자일과의-유사점"><span class="icon icon-link"></span></a>DDD 적용 사이클 &amp; 애자일과의 유사점</h3>
<p><img src="/img/post/ddd/ddd-cycle.png" alt="DDD 적용 사이클"/></p>
<p>DDD 의 적용 흐름 사이클은 애자일 방법론과 매우 밀접하게 연관이 있는데, 두 접근법 모두 반복적이고 점진적인 개선을 중요시 한다는 특성이 있다.</p>
<p><strong>반복적 개발</strong></p>
<ul>
<li>한 번에 완벽한 시스템을 구축하기 보다는 <strong>반복적인 사이클</strong> 을 통해 <strong>점진적</strong> 으로 시스템을 발전 시키는 접근법이다.</li>
</ul>
<p><strong>지속적인 피드백</strong></p>
<ul>
<li>애자일에서 중요시하는 지속적인 피드백 루프가 DDD 의 테스트 - 리팩토팅 - 도메인 분석 순환과 유사하다.</li>
</ul>
<p><strong>협업 중심</strong></p>
<ul>
<li>애자일은 개발자와 이해관계자 간의 긴밀한 협업을 강조하고, DDD 는 도메인 전문가와 개발자 간의 지식 공유와 협업이 핵심이다.</li>
</ul>
<p><strong>변화 수용</strong></p>
<ul>
<li>애자일과 DDD 모두 요구사항과 이해의 변화를 자연스럽게 수용하는 프레임워크를 제공한다고 볼 수 있다.</li>
</ul>
<p><strong>점진적 모델 개선</strong></p>
<ul>
<li>애자일의 점진적 개발 방식은 DDD 에서 도메인 모델을 점진적으로 발견하고 개선해 나가는 과정과 동일하다고 볼 수 있다.</li>
</ul>
<div class="px-4 py-2 my-4 rounded bg-indigo-50 border-l-4 border-indigo-400 text-indigo-900"><div class="prose-sm"><p><b>DDD의 핵심 가치</b><br/>
도메인 중심 설계는 일관성을 유지하며, 시스템을 명확하게 분할할 수 있도록 돕는다.</p></div></div>
<hr/>
<h3 id="-실용적인-적용-tips"><a aria-hidden="true" tabindex="-1" href="#-실용적인-적용-tips"><span class="icon icon-link"></span></a>💡 실용적인 적용 Tips</h3>
<ul>
<li><strong>정형화 강박 금지</strong>: 상황에 따라 유연하게 모델링</li>
<li><strong>초기 VO 모델링 → Entity로 승격</strong></li>
<li><strong>반복적 개선</strong>을 전제로 설계</li>
</ul>
<hr/>
<div class="px-4 py-2 my-4 rounded bg-green-50 border-l-4 border-green-400 text-green-900"><div class="prose-sm"><p>💡 <b>정리</b><br/>
DDD 는 복잡한 도메인을 코드로 명확하게 표현하기 위한 사고방식이다. <br/>
도메인 모델과 코드 모델의 일관성 유지, 불변식 보장, 행위 중심 모델링이 핵심이며,
패턴을 무조건 따르기보단 <b>상황에 맞는 유연한 적용</b>이 중요하다. <br/>
→ 오버엔지니어링을 경계 해야 한다.</p></div></div>
<hr/>
<h3 id="-reference"><a aria-hidden="true" tabindex="-1" href="#-reference"><span class="icon icon-link"></span></a>📚 Reference</h3>
<ul>
<li><a href="https://www.yes24.com/Product/Goods/5312881">도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜</a></li>
<li><a href="https://edu.nextstep.camp/c/SXgXIKdd/">조영호님 강의: 도메인 주도 설계의 사실과 오해</a></li>
</ul>
<br/>
<br/></article></main><aside class="hidden lg:block w-48 pl-6"><div class="sticky top-24 text-sm leading-relaxed space-y-2"><h2 class="text-lg font-bold mb-3">📑 목차</h2><ul class="space-y-1 text-sm text-gray-700"></ul></div></aside></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"ddd-core-concept","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    info: \"info\",\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    span: \"span\",\n    quote: \"quote\",\n    hr: \"hr\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    ul: \"ul\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    note: \"note\",\n    success: \"success\"\n  }, _provideComponents(), props.components), {BlueText} = _components;\n  if (!BlueText) _missingMdxReference(\"BlueText\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.info, {\n      children: _jsx(_components.p, {\n        children: \"도메인 주도 설계(DDD, Domain-Driven Design)는 단순한 방법론이 아닌 도메인 중심의 개발 접근법이다.\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"intro\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#intro\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Intro\"]\n    }), \"\\n\", _jsx(_components.quote, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"Nextstep 에서 진행하는 조영호님의 강의인 \\\"도메인 주도 설계의 사실과 오해\\\"\"\n        }), \" 에서 배운 내용을 요약하고 정리한 부분이 포함되어 있다. \", _jsx(\"br\", {}), \"\\n책으로 읽었던 내용들을 다시 정리할 수 있었던 부분들이 많았고, 개념정리를 다시 할 수 있어서 좋았는데, 개인적으로는 연차를 막론하고 적극 추천한다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"도메인-주도-설계의-본질\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#도메인-주도-설계의-본질\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"도메인 주도 설계의 본질\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd.png\",\n        alt: \"ddd본질\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"접근법\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"DDD는 프로세스나 방법론이 아닌 \", _jsx(BlueText, {\n          children: \"패턴의 집합\"\n        }), \"이며, 상황에 맞게 \", _jsx(BlueText, {\n          children: \"선택적으로\"\n        }), \" 적용해야 한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"모델링 사이클\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"도메인 모델 = 코드 모델\"\n        }), \" 이며, 도메인이 바뀌면 코드도 바뀌고 그 반대도 성립한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"구현 가이드\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"빌딩 블록을 통해 도메인의 개념을 코드로 옮기며 \", _jsx(BlueText, {\n          children: \"복잡도를 줄인다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"불변식 기반\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Aggregate 단위의 일관성을 유지하며, 도메인 규칙의 불변성을 코드로 보장한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"엔티티-vs-값-객체\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#엔티티-vs-값-객체\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"엔티티 vs 값 객체\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"엔티티 (Entity)\"\n          }), _jsx(_components.th, {\n            children: \"값 객체 (Value Object)\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별성이 중요\"\n          }), _jsx(_components.td, {\n            children: \"속성이 중요\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"가변 (상태 변경 가능)\"\n          }), _jsx(_components.td, {\n            children: \"불변 (상태 변경 불가)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"식별자로 동일성 비교\"\n          }), _jsx(_components.td, {\n            children: \"속성 값으로 동등성 비교\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"생명 주기 추적 필요\"\n          }), _jsx(_components.td, {\n            children: \"대체 가능 / 엔티티의 복잡성 감소\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Entity\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"식별자\"\n        }), \" 로 구분되며, 상태 변경이 가능하다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"생명 주기 관리가 필요하며, \", _jsx(BlueText, {\n          children: \"동일성 비교가 중요하다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Value Object\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(BlueText, {\n          children: \"속성\"\n        }), \" 이 중요하고, \", _jsx(BlueText, {\n          children: \"불변성\"\n        }), \"을 가진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Entity 의 복잡성을 줄이는 역할을 수행한다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"값이 같으면 동일한 객체로 취급하며, \", _jsx(BlueText, {\n          children: \"동등성 비교가 핵심이다.\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"상태 변경 로직은 \", _jsx(\"b\", {\n          children: \" Entity \"\n        }), \" 에 집중시키고, 값을 \", _jsx(\"b\", {\n          children: \"Value Object\"\n        }), \" 로 추출해 구조를 단순화하자.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"어그리게이트-aggregate\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#어그리게이트-aggregate\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"어그리게이트 (Aggregate)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/aggregate.png\",\n        alt: \"aggregate\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"정의\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"여러 Entity 와 Value Object 를 하나로 묶는 단위\\n\", _jsx(_components.strong, {\n          children: \"경계\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 는 캡슐화 경계를 형성하며, 외부에서는 \", _jsx(BlueText, {\n          children: \"루트 엔티티만 참조\"\n        }), \" 가능\\n\", _jsx(_components.strong, {\n          children: \"트랜잭션\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 처리\\n\", _jsx(_components.strong, {\n          children: \"불변식\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내부 도메인 상태의 일관성을 보장\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.note, {\n      children: _jsxs(_components.p, {\n        children: [\"루트 Entity 는 전역 식별성을 가지고 있고, 궁극적으로 불변식을 검사할 책임이 있다. \", _jsx(\"br\", {}), \"\\n경계 안의 Entity 는 지역 식별성을 가지고 있으며, 외부에서는 무조건 루트 Entity 만 참조 가능하다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"리포지토리-repository\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#리포지토리-repository\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"리포지토리 (Repository)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"역할\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Aggregate 단위로 \", _jsx(BlueText, {\n          children: \"영속성\"\n        }), \" 을 관리하며, 데이터 저장 및 검색을 담당하다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DDD 에서는 원래는 Repository 는 컬렉션과 비슷한데, 메모리상에 객체가 있는 것처럼 쓰는 객체이지만 현대에는 Database 라고 보면 된다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"설계 원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"객체 단위가 아닌 \", _jsx(BlueText, {\n          children: \"Aggregate 단위\"\n        }), \"로 Repository 를 생성한다. (Aggregate 당 하나의 Repository)\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID를 통해 외부에서 참조, 내부에서는 객체로 참조한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"연관-관계-설계-원칙\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#연관-관계-설계-원칙\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"연관 관계 설계 원칙\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계원칙\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"도메인 중심의 \", _jsx(_components.strong, {\n          children: \"행위 기반 모델링\"\n        }), \"이 중요하며, 연관 관계는 최소화해야 유지보수성이 좋아진다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"양방향 참조는 복잡성을 증가시키므로 가급적이면 단방향으로 설계한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"1대 N 관계는 지연 로딩 문제로 인해서 선호하지 않고, N대 1 관계를 선호한다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ID 참조를 통해 외부 참조를 최소화하고, Aggregate 내부에서는 객체 참조를 통해 탐색한다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"서비스-계층-구조\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#서비스-계층-구조\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"서비스 계층 구조\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/service-hierarchy.png\",\n        alt: \"서비스계층구조\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"도메인 서비스\"\n        }), \": 도메인 로직이지만 Aggregate 에 넣기 애매한 로직 담당\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"애플리케이션 서비스\"\n        }), \": 비즈니스 흐름을 조합\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"인프라 서비스\"\n        }), \": 외부 시스템과 연결 (DB, MQ 등)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"설계-접근법\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#설계-접근법\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"설계 접근법\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/design-principles.png\",\n        alt: \"설계접근법\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"책임 주도 설계 → 객체지향 사고를 기반으로 설계\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"계약에 의한 설계 → \", _jsx(BlueText, {\n          children: \"불변식\"\n        }), \" 을 기준으로 로직을 구성\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"ddd-적용-사이클--애자일과의-유사점\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#ddd-적용-사이클--애자일과의-유사점\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"DDD 적용 사이클 \u0026 애자일과의 유사점\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/img/post/ddd/ddd-cycle.png\",\n        alt: \"DDD 적용 사이클\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DDD 의 적용 흐름 사이클은 애자일 방법론과 매우 밀접하게 연관이 있는데, 두 접근법 모두 반복적이고 점진적인 개선을 중요시 한다는 특성이 있다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"반복적 개발\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"한 번에 완벽한 시스템을 구축하기 보다는 \", _jsx(_components.strong, {\n          children: \"반복적인 사이클\"\n        }), \" 을 통해 \", _jsx(_components.strong, {\n          children: \"점진적\"\n        }), \" 으로 시스템을 발전 시키는 접근법이다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"지속적인 피드백\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일에서 중요시하는 지속적인 피드백 루프가 DDD 의 테스트 - 리팩토팅 - 도메인 분석 순환과 유사하다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"협업 중심\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일은 개발자와 이해관계자 간의 긴밀한 협업을 강조하고, DDD 는 도메인 전문가와 개발자 간의 지식 공유와 협업이 핵심이다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"변화 수용\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일과 DDD 모두 요구사항과 이해의 변화를 자연스럽게 수용하는 프레임워크를 제공한다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"점진적 모델 개선\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애자일의 점진적 개발 방식은 DDD 에서 도메인 모델을 점진적으로 발견하고 개선해 나가는 과정과 동일하다고 볼 수 있다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.quote, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"b\", {\n          children: \"DDD의 핵심 가치\"\n        }), _jsx(\"br\", {}), \"\\n도메인 중심 설계는 일관성을 유지하며, 시스템을 명확하게 분할할 수 있도록 돕는다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-실용적인-적용-tips\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-실용적인-적용-tips\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"💡 실용적인 적용 Tips\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"정형화 강박 금지\"\n        }), \": 상황에 따라 유연하게 모델링\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"초기 VO 모델링 → Entity로 승격\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"반복적 개선\"\n        }), \"을 전제로 설계\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.success, {\n      children: _jsxs(_components.p, {\n        children: [\"💡 \", _jsx(\"b\", {\n          children: \"정리\"\n        }), _jsx(\"br\", {}), \"\\nDDD 는 복잡한 도메인을 코드로 명확하게 표현하기 위한 사고방식이다. \", _jsx(\"br\", {}), \"\\n도메인 모델과 코드 모델의 일관성 유지, 불변식 보장, 행위 중심 모델링이 핵심이며,\\n패턴을 무조건 따르기보단 \", _jsx(\"b\", {\n          children: \"상황에 맞는 유연한 적용\"\n        }), \"이 중요하다. \", _jsx(\"br\", {}), \"\\n→ 오버엔지니어링을 경계 해야 한다.\"]\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h3, {\n      id: \"-reference\",\n      children: [_jsx(_components.a, {\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        href: \"#-reference\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"📚 Reference\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.yes24.com/Product/Goods/5312881\",\n          children: \"도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://edu.nextstep.camp/c/SXgXIKdd/\",\n          children: \"조영호님 강의: 도메인 주도 설계의 사실과 오해\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {})]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."}},"title":"도메인 주도 설계의 핵심 개념","date":"2025-03-01","tags":["DDD"],"summary":"Domain-Driven Design Core Concept","description":"도메인 주도 설계(DDD, Domain-Driven Design) 의 핵심 개념에 대해서 알아보자."}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"ddd-core-concept"},"buildId":"lO0LaOnoEt2PK4Zp9myxs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>